[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "Introduction\nWelcome to the Mannheim Master in Management Analytics - Accounting Class of 2024 practical application sessions. Over the next two days, we will delve into the application of R and Excel to address prevalent business challenges, with a particular focus on web-scraping. Our aim is to equip you with insights into the automation and optimization of routine workflows.\nWhile the sessions are designed in R, a foundational understanding of programming is crucial. We will methodically break down the advanced techniques used in the code for better comprehension.\n\n\nResources and Assistance\nEngage in guided in-class exercises throughout these sessions. This year, we’re bolstered by the support of Large Language Models (LLMs). I strongly advocate for the utilization of these tools to amplify your learning experience. Here’s a snapshot of some leading LLMs:\n\nChatGPT (3.5/4.0): A distinguished tool in the AI domain.\nPerplexity AI: Harnessing the GPT-4 framework, it offers native web-searching capabilities.\nGoogle Bard: A notable AI tool in the market.\nClaude AI: Accessible primarily in US/UK; VPN can provide broader access.\n\nFor effective prompting, consider:\n\nPromptPerfect: Enhance your prompting skills.\nPromptoMania: An AI-driven prompt generator.\n\nDisclaimer:\nLLMs may produce diverse results. Some might provide direct solutions, while others may necessitate further adjustments. The primary goal is understanding, not necessarily mastering every coding detail. The overarching principle is: If it’s effective, it’s right!\n\n\nSetting Up R and Rstudio\nR and RStudio installations are imperative for our interactive exercises. The setup is intuitive. Kindly follow the instructions to install the necessary components. We’re here to assist should you face any challenges.\n\n\nAccessing the Code\nThe comprehensive codebase for our sessions is hosted on my GitHub page: MatthiasUckert/RpMMA24. You can either fork the repository to your GitHub account or download the project directly.\n\n\nTable of Content\nNavigate through the sessions using the links in this table or the drop-down menus atop the page.\n\n\n\nDay\nDescription\n\n\n\n\nDay 1\nBuilding an Excel Business Case\nConstruct a concise business case in Excel, evaluating a business decisions using metrics like the Contribution Margin\n\n\nDay 2\nGetting Data from the Web\nMaster web scraping in scenarios with and without an API.\n\nhttp://www.annualreport.com/\nhttps://www.sec.gov/edgar\n\n\n\n\n\n\n\nInteresting Readings\n\nAdvanced R: https://adv-r.hadley.nz/\nR for Data Science: https://r4ds.had.co.nz/\nHands-On Programming With R: https://rstudio-education.github.io/hopr/"
  },
  {
    "objectID": "exercises/day1.html",
    "href": "exercises/day1.html",
    "title": "Day 1 - Building a Performance Measure Case",
    "section": "",
    "text": "Today’s complex business environment demands tools that offer both versatility and precision. In this session, we’ll explore three vital financial tasks using the R programming environment:\n\nCost Allocation: Get a granular understanding of how costs disperse across products, emphasizing the allocation of indirect costs.\nContribution Margin Analysis: Examine the profitability of individual products, distinguishing which products significantly impact the bottom line.\nMonte-Carlo Analysis: Navigate business uncertainties with this statistical technique, utilizing random sampling to achieve numerical results for multifaceted problems.\n\nBut why opt for R over mainstream tools like Excel?\nThe Case for R:\n\nReproducibility: With R scripts, analyses can be reproduced and validated effortlessly. This is invaluable for audits or simply revisiting your work months or years later.\nHandling Large Data sets: R is equipped to manage extensive datasets, something Excel struggles with beyond a point.\nFlexibility: R’s vast array of packages and its ability to integrate with other languages and tools make it highly adaptable.\nAdvanced Statistical Analysis: While Excel offers basic statistical tools, R provides a comprehensive suite for sophisticated analyses.\nCost-Effective: Being open-source, R is freely available, ensuring businesses don’t incur additional software costs.\n\nBy the session’s end, you’ll appreciate not just the theoretical aspects of these techniques but also the practical advantages of implementing them in an open-source environment like R.\nLet’s get started!"
  },
  {
    "objectID": "exercises/day1.html#task-1-allocate-indirect-cost",
    "href": "exercises/day1.html#task-1-allocate-indirect-cost",
    "title": "Day 1 - Building a Performance Measure Case",
    "section": "Task 1: Allocate Indirect Cost",
    "text": "Task 1: Allocate Indirect Cost\nWe know that we have to allocate indirect costs onto the individual product. Let’s tale Material Cost as an example:\n\nDirect Cost Elite (DC1): 30,000 €\nDirect Cost Premium (DC2): 70,000 €\nIndirect Cost (IC): 40,000\n\nThe general Formula for allocating indirect Cost is:\n\\[\nIC_{c,i} = IC_{c}*\\frac{DC_{c,i}}{\\sum_{i} DC_i}\n\\]\n\nTask 1A: Material Cost Allocation Preparation\nUse the given data to calculate the cost allocation:\n\nmat_dic &lt;- c(\"Elite\" = 30000, \"Premium\" = 70000)\nmat_inc &lt;- 40000\n\nToDo: Calculate the correct value for mat_ac\n\nmat_alc &lt;- NULL # YOUR CALCULATION HERE\nmat_alc &lt;- mat_inc * (mat_dic / sum(mat_dic))\nmat_alc\n\n  Elite Premium \n  12000   28000 \n\n\nCheck Your Result\n\ncheck_named_vector(mat_alc, c(\"Elite\" = 12000, \"Premium\" = 28000))\n\nSuccess: Correct Values and Names\n\n\n\n\nTask 1B: Write a general cost allocation formula\nEnsure the function only accepts named numeric vectors.\nName conventions: .m_dic for the direct cost vector, and .s_inc for the indirect cost (m_ stands for multiple values and s_ stands for single values).\n\nallocate_indirect_cost &lt;- function(.m_dic, .s_inc) {\n  # YOUR CODE HERE\n}\n\nallocate_indirect_cost &lt;- function(.m_dic, .s_inc) {\n  if (!is.numeric(.m_dic)) stop(\".m_dic must be a numeric vector\", call. = FALSE)\n  if (all(is.null(names(.m_dic)))) stop(\".m_dic must be a named vector\", call. = FALSE)\n  if (any(names(.m_dic) == \"\")) stop(\"All elements of .m_dic must be named\", call. = FALSE)\n  \n  .m_dic * (.s_inc / sum(.m_dic))\n}\n\nmat_alc &lt;- allocate_indirect_cost(mat_dic, mat_inc)\n\nCheck Your Result\n\ncheck_named_vector(mat_alc, c(\"Elite\" = 12000, \"Premium\" = 28000))\n\nSuccess: Correct Values and Names"
  },
  {
    "objectID": "exercises/day1.html#task-2-summing-cost-vectors",
    "href": "exercises/day1.html#task-2-summing-cost-vectors",
    "title": "Day 1 - Building a Performance Measure Case",
    "section": "Task 2: Summing Cost Vectors",
    "text": "Task 2: Summing Cost Vectors\nThe goal here is to devise a formula that can take multiple named numeric vectors as its input and return a new vector whose elements are the piece-wise sum of the elements in the input vectors. This formula will allow you to combine, for example, direct costs and allocated indirect costs to derive the total costs.\n\nTask 2A: Cost Summation Formula\nYou aim to create a function, sum_cost, that can receive any number of named numeric vectors and return their piece-wise sum.\nThe two common methods in R to handle an arbitrary number of function inputs are:\n\nUsing a list: Each vector is considered an item in the list. This method is more structured but requires each vector to be manually added to the list.\nUsing the ... operator: This is a placeholder for any number of arguments that can be passed to a function. It provides flexibility because you don’t have to specify in advance how many arguments you’re going to use. Later, inside the function, you can convert ... to a list using the list(...) function, allowing you to manipulate the arguments as a single list object.\n\nGiven these methods, here’s how you can create the sum_cost function:\n\nsum_cost &lt;- function(...) {\n  # YOUR CODE HERE\n}\n\nsum_cost &lt;- function(...) {\n  purrr::pmap_dbl(list(...), sum)\n}\n\n\nmat_tot &lt;- sum_cost(mat_dic, mat_inc )\n\nCheck Your Result\n\ncheck_named_vector(mat_tot, c(\"Elite\" = 70000, \"Premium\" = 110000))\n\nSuccess: Correct Values and Names"
  },
  {
    "objectID": "exercises/day1.html#task-3-using-real-data-for-cost-allocation",
    "href": "exercises/day1.html#task-3-using-real-data-for-cost-allocation",
    "title": "Day 1 - Building a Performance Measure Case",
    "section": "Task 3: Using Real Data for Cost Allocation",
    "text": "Task 3: Using Real Data for Cost Allocation\nTo understand and compute the cost allocation using the lecture data, we’ll extract it from an Excel sheet and perform specific operations based on the data’s structure.\n\ntab_cost &lt;- tibble::as_tibble(\n  openxlsx::read.xlsx(\"../Business Case.xlsx\", \"Cost1\")\n  ) %&gt;%\n  janitor::clean_names()\ntab_cost\n\n# A tibble: 9 x 6\n  type     product department    amount distr   range_std\n  &lt;chr&gt;    &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;\n1 Direct   Elite   Material       30000 normal       5000\n2 Direct   Premium Material       70000 normal       7500\n3 Indirect &lt;NA&gt;    Material       40000 uniform      5000\n4 Direct   Elite   Manufacturing  40000 normal       2500\n5 Direct   Premium Manufacturing  50000 normal       1500\n6 Indirect &lt;NA&gt;    Manufacturing 135000 uniform     25000\n7 Indirect &lt;NA&gt;    Admin          73000 uniform      7500\n8 Indirect &lt;NA&gt;    Marketing      36500 uniform      3750\n9 Company  &lt;NA&gt;    &lt;NA&gt;           30000 uniform     22500\n\n\nHere, we use the openxlsx package to read the specific sheet “Cost1” from the Excel file. This data is then converted into a tibble (a modern form of R’s data frame) for easier manipulation. The clean_names() function from the janitor package is used to ensure our column names are consistent and easy to work with.\n\nTask 3A: Writing a formula to read product cost\nObjective: For this task, your goal is to write a function named filter_cost_input that filters the data for a specific cost type (e.g., Direct or Indirect) and a specific department (e.g., Material, Manufacturing). This function should return a named numeric vector where names are products, and values are the associated costs.\nYOUR FUNCTION:\n\nfilter_cost_input &lt;- function(.tab, .type, .dep) {\n  # YOUR CODE HERE\n}\n\nInstructions:\n\nUse the filter() function from the dplyr package to filter the table based on the given cost type and department.\nAfter filtering, arrange the results based on the product name. This will ensure consistency in later steps.\nNow, you’ll need to generate a named vector from the filtered results. This can be achieved using the mutate() function to set the names of the amount column to be the respective product names.\nFinally, extract just the named amount vector using the pull() function.\n\n\nfilter_cost_input &lt;- function(.tab, .type, .dep) {\n  .tab %&gt;%\n    dplyr::filter(type == .type, department == .dep) %&gt;%\n    dplyr::arrange(product) %&gt;%\n    dplyr::mutate(amount = purrr::set_names(amount, product)) %&gt;%\n    dplyr::pull(amount)\n}\n\nCheck Your Result\n\nmat_dic &lt;- filter_cost_input(tab_cost, \"Direct\", \"Material\")\nmat_dic\n\n  Elite Premium \n  30000   70000 \n\n\n\ncheck_named_vector(mat_dic, c(\"Elite\" = 30000, \"Premium\" = 70000))\n\nSuccess: Correct Values and Names\n\n\n\n\nTask 3B: Writing formulas to get Cost Allocation List\nObjective: The aim of this exercise is to calculate different types of costs, both direct and indirect, and allocate them properly across products.\nStep-by-Step Guide:\n\nUnderstand the Structure: The get_cost_allocations function will compute various costs and store them in a list. This list will help organize and categorize costs according to their type and department.\nMaterial Costs:\n\nDirect Material Cost (mat_dic): This is already computed for you using the filter_cost_input function. It represents the costs directly linked to materials for each product.\nIndirect Material Cost (mat_inc): These costs are associated with materials but can’t be linked to a specific product. Instead, they’re spread out across all products.\nAllocated Material Cost (mat_alc): Here, you need to allocate the indirect material cost across all products based on some allocation rule (like proportion of direct costs or units produced). Use the allocate_indirect_cost function with mat_dic and mat_inc as arguments.\nTotal Material Cost (mat_tot): This is the sum of direct material cost and allocated indirect material cost. Use the sum_cost function.\n\nManufacturing Costs:\n\nDirect Manufacturing Cost (man_dic) and Indirect Manufacturing Cost (man_inc): These are computed in a manner similar to material costs.\nAllocated Manufacturing Cost (man_alc): Allocate the indirect manufacturing cost across products. Consider factors like machine hours or labor hours if relevant.\nTotal Manufacturing Cost (man_tot): Sum up the direct and allocated indirect manufacturing costs.\n\nAdministrative Costs:\n\nIndirect Admin Cost (adm_inc): As administrative costs are often indirect, allocate these across products based on a suitable allocation base (e.g., total costs or sales).\nAllocated Admin Cost (adm_alc): Spread the indirect admin cost using an appropriate rule.\n\nMarketing Costs:\n\nIndirect Marketing Cost (mar_inc): These are the costs associated with marketing activities that can’t be directly linked to a product.\nAllocated Marketing Cost (mar_alc): Distribute the marketing costs among products.\n\nTotal Product Cost (prd_tot): This is a summation of all costs associated with a product - material, manufacturing, administrative, and marketing. Ensure all costs are considered, both direct and allocated indirect.\n\nUse the Functions allocate_indirect_cost() and sum_cost() to complete the get_cost_allocations() functions\nYOUR FUNCTION:\n\nget_cost_allocations &lt;- function(.tab_cost) {\n  # Create an empty list to store values\n  lst_ &lt;- list()\n\n  # Material Cost\n  lst_[[\"mat_dic\"]] &lt;- filter_cost_input(.tab_cost, \"Direct\", \"Material\")   # Direct Material Cost\n  lst_[[\"mat_inc\"]] &lt;- filter_cost_input(.tab_cost, \"Indirect\", \"Material\") # Indirect Material Cost\n  lst_[[\"mat_alc\"]] &lt;- NULL # YOUR CODE HERE                                # Allocated Material Cost\n  lst_[[\"mat_tot\"]] &lt;- NULL # YOUR CODE HERE                                # Total Material Cost\n\n  # Manufacturing Cost\n  lst_[[\"man_dic\"]] &lt;- filter_cost_input(.tab_cost, \"Direct\", \"Manufacturing\")   # Direct Manufacturing Cost\n  lst_[[\"man_inc\"]] &lt;- filter_cost_input(.tab_cost, \"Indirect\", \"Manufacturing\") # Indirect Manufacturing Cost\n  lst_[[\"man_alc\"]] &lt;- NULL # YOUR CODE HERE                                     # Allocated Manufacturing Cost\n  lst_[[\"man_tot\"]] &lt;- NULL # YOUR CODE HERE                                     # Total Manufacturing Cost\n\n  # Administrative Cost\n  lst_[[\"adm_inc\"]] &lt;- filter_cost_input(.tab_cost, \"Indirect\", \"Admin\") # Indirect Admin Cost\n  lst_[[\"adm_alc\"]] &lt;- NULL # YOUR CODE HERE                             # Allocated Admin Cost\n\n  # Marketing Cost\n  lst_[[\"mar_inc\"]] &lt;- filter_cost_input(.tab_cost, \"Indirect\", \"Marketing\") # Indirect Marketing Cost\n  lst_[[\"mar_alc\"]] &lt;- NULL # YOUR CODE HERE                                 # Allocated Marketing Cost\n\n  # Total Product Cost\n  lst_[[\"prd_tot\"]] &lt;- NULL # YOUR CODE HERE\n\n  return(lst_)\n}\n\n\nget_cost_allocation_list &lt;- function(.tab_cost) {\n  lst_ &lt;- list()\n\n  lst_[[\"mat_dic\"]] &lt;- filter_cost_input(.tab_cost, \"Direct\", \"Material\")\n  lst_[[\"mat_inc\"]] &lt;- filter_cost_input(.tab_cost, \"Indirect\", \"Material\")\n  lst_[[\"mat_alc\"]] &lt;- allocate_indirect_cost(lst_$mat_dic, lst_$mat_inc)\n  lst_[[\"mat_tot\"]] &lt;- sum_cost(lst_$mat_dic, lst_$mat_alc)\n\n  lst_[[\"man_dic\"]] &lt;- filter_cost_input(.tab_cost, \"Direct\", \"Manufacturing\")\n  lst_[[\"man_inc\"]] &lt;- filter_cost_input(.tab_cost, \"Indirect\", \"Manufacturing\")\n  lst_[[\"man_alc\"]] &lt;- allocate_indirect_cost(lst_$man_dic, lst_$man_inc)\n  lst_[[\"man_tot\"]] &lt;- sum_cost(lst_$mat_tot, lst_$man_dic, lst_$man_alc)\n\n  lst_[[\"adm_inc\"]] &lt;- filter_cost_input(.tab_cost, \"Indirect\", \"Admin\")\n  lst_[[\"adm_alc\"]] &lt;- allocate_indirect_cost(lst_$man_tot, lst_$adm_inc)\n\n  lst_[[\"mar_inc\"]] &lt;- filter_cost_input(.tab_cost, \"Indirect\", \"Marketing\")\n  lst_[[\"mar_alc\"]] &lt;- allocate_indirect_cost(lst_$man_tot, lst_$mar_inc)\n\n  lst_[[\"prd_tot\"]] &lt;- sum_cost(lst_$man_tot, lst_$adm_alc, lst_$mar_alc)\n\n  return(lst_)\n}\n\nFunction Breakdown:\n\nFunction Name: get_cost_allocation_skeleton\n\nThis name suggests that we are fetching or creating a foundational structure for our cost allocations.\n\nThe tibble::tribble Function:\n\nThis function is from the tibble package and helps in creating a small table (or tibble) in a readable form.\nThe ~sign and ~var are column names in this table. Each subsequent line in the function provides a row of data for these columns.\n\n\nUsage:\nWhen you call the function, it returns the described tibble structure. This “skeleton” serves as a roadmap for allocating and tallying up various costs. As you proceed with the exercise, you will populate this table with actual monetary values corresponding to each cost type. This visual representation helps in comprehending the flow and accumulation of different cost components.\n\nget_cost_allocation_skeleton &lt;- function() {\n  tibble::tribble(\n    ~sign, ~var,\n    \" \", \"Direct Material Costs\",\n    \"+\", \"Indirect Material Costs\",\n    \"=\", \"Material Costs\",\n    \"+\", \"Direct Manufacturing Costs\",\n    \"+\", \"Indirect Manufacturing Costs\",\n    \"=\", \"Manufacturing Costs\",\n    \"+\", \"Indirect Administration Costs\",\n    \"+\", \"Indirect Marketing Costs\",\n    \"=\", \"Total Product Costs\"\n  )\n}\n\n\nget_cost_allocation_skeleton()\n\n# A tibble: 9 x 2\n  sign  var                          \n  &lt;chr&gt; &lt;chr&gt;                        \n1 \" \"   Direct Material Costs        \n2 \"+\"   Indirect Material Costs      \n3 \"=\"   Material Costs               \n4 \"+\"   Direct Manufacturing Costs   \n5 \"+\"   Indirect Manufacturing Costs \n6 \"=\"   Manufacturing Costs          \n7 \"+\"   Indirect Administration Costs\n8 \"+\"   Indirect Marketing Costs     \n9 \"=\"   Total Product Costs          \n\n\n\n\nTask 3C: Display Cost Allocation Table\nIn this task, your goal is to use the pre-defined functions get_cost_allocation_list() and get_cost_allocation_skeleton() to construct the final Cost Allocation Table.\nThe Cost Allocation Table is crucial because it breaks down both direct and indirect costs, allowing a company to understand its cost structure better. By the end of this task, you should be able to represent all these costs in a well-organized table.\nInstructions:\n\nUnderstanding the Skeleton:\n\nBefore jumping into building the entire table, let’s familiarize ourselves with the get_cost_allocation_skeleton() function. This function provides a structured, step-by-step representation of how costs are compiled. Each row of the output represents either an individual cost or a summation.\nTry running the function by itself to see its output!\n\nFetching the Costs:\n\nThe get_cost_allocation_list() function is designed to extract various types of costs from the dataset. It returns a list containing costs categorized by their type (direct, indirect) and nature (material, manufacturing, etc.).\nFor the purpose of this task, run the function with your dataset and examine its output. Familiarize yourself with the different types of costs it provides.\n\nBuilding the Table:\n\nYour main challenge is to construct the Cost Allocation Table. This will involve integrating the structure provided by the skeleton with the actual cost data.\nThink of how you can combine the structured format of the skeleton with the actual cost numbers. You’ll need to fetch each relevant cost from the list and place it in the correct position within the table.\nNote: The skeleton uses signs like “+” and “=” to signify addition and summation. This can guide you on where and how to place and calculate costs.\n\nSteps to Consider for the Function:\n\nStart by fetching the costs using get_cost_allocation_list().\nUse the output of get_cost_allocation_skeleton() as your foundational table.\nFor each line in the skeleton, fetch the corresponding cost from your list and append it as a new column to the table.\nOnce you’ve placed all the individual costs, think about the rows that require summation (those with “=”). Calculate these using the appropriate rows.\nContinue this process until you’ve constructed the entire table.\nAdd a Total Column to the Table that shows the total cost over all Products\n\nTesting:\n\nOnce you’ve written your function, test it with the given data. Your output should align with the structure of the skeleton and display all the relevant costs.\n\n\nTips:\n\nRemember, you’re not starting from scratch! You have a structured format and categorized data. It’s all about bringing them together in the right order.\nThe use of functions from packages like dplyr and purrr can significantly simplify data manipulation and transformation. If you’re familiar with these, consider how they can assist in your task.\n\n\nget_cost_allocation_table &lt;- function(.tab_cost) {\n  # YOUR CODE HERE\n}\n\nget_cost_allocation_table &lt;- function(.tab_cost) {\n  lst_cost_ &lt;- get_cost_allocation_list(.tab_cost)\n  lst_cost_ &lt;- lst_cost_[c(\n    \"mat_dic\", \"mat_alc\", \"mat_tot\", \n    \"man_dic\", \"man_alc\", \"man_tot\", \n    \"adm_alc\", \n    \"mar_alc\", \n    \"prd_tot\"\n  )]\n  \n  make_table_row &lt;- function(.vec) {\n    tibble::as_tibble(t(.vec))\n  }\n  \n  get_cost_allocation_skeleton() %&gt;%\n    dplyr::bind_cols(\n      dplyr::bind_rows(purrr::map(lst_cost_, make_table_row))\n      ) %&gt;%\n    dplyr::mutate(Total = rowSums(.[, -(1:2)]), .after = var)\n}\n\n\nget_cost_allocation_table(.tab_cost = tab_cost)\n\n# A tibble: 9 x 5\n  sign  var                            Total  Elite Premium\n  &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;\n1 \" \"   Direct Material Costs         100000  30000   70000\n2 \"+\"   Indirect Material Costs        40000  12000   28000\n3 \"=\"   Material Costs                140000  42000   98000\n4 \"+\"   Direct Manufacturing Costs     90000  40000   50000\n5 \"+\"   Indirect Manufacturing Costs  135000  60000   75000\n6 \"=\"   Manufacturing Costs           365000 142000  223000\n7 \"+\"   Indirect Administration Costs  73000  28400   44600\n8 \"+\"   Indirect Marketing Costs       36500  14200   22300\n9 \"=\"   Total Product Costs           474500 184600  289900\n\n\n\nformat_table(get_cost_allocation_table(tab_cost))\n\n\n\n\n\n  \n    \n    \n      sign\n      var\n      Total\n      Elite\n      Premium\n    \n  \n  \n     \nDirect Material Costs\n100,000\n30,000\n70,000\n    +\nIndirect Material Costs\n40,000\n12,000\n28,000\n    =\nMaterial Costs\n140,000\n42,000\n98,000\n    +\nDirect Manufacturing Costs\n90,000\n40,000\n50,000\n    +\nIndirect Manufacturing Costs\n135,000\n60,000\n75,000\n    =\nManufacturing Costs\n365,000\n142,000\n223,000\n    +\nIndirect Administration Costs\n73,000\n28,400\n44,600\n    +\nIndirect Marketing Costs\n36,500\n14,200\n22,300\n    =\nTotal Product Costs\n474,500\n184,600\n289,900"
  },
  {
    "objectID": "exercises/day1.html#task-4a-subtracting-cost-vectors-for-revenue-vectors",
    "href": "exercises/day1.html#task-4a-subtracting-cost-vectors-for-revenue-vectors",
    "title": "Day 1 - Building a Performance Measure Case",
    "section": "Task 4A: Subtracting Cost Vectors for Revenue Vectors",
    "text": "Task 4A: Subtracting Cost Vectors for Revenue Vectors\nYou aim to create a function, substract_cost, that can receive any number of named numeric vectors and subtract values from the first value.\nThe two common methods in R to handle an arbitrary number of function inputs are:\n\nUsing a list: Each vector is considered an item in the list. This method is more structured but requires each vector to be manually added to the list.\nUsing the ... operator: This is a placeholder for any number of arguments that can be passed to a function. It provides flexibility because you don’t have to specify in advance how many arguments you’re going to use. Later, inside the function, you can convert ... to a list using the list(...) function, allowing you to manipulate the arguments as a single list object.\n\nGiven these methods, here’s how you can create the substract_cost function:\n\nsubtract_cost &lt;- function(...) {\n  purrr::pmap_dbl(list(...), ~ sum(c(...)[1], -c(...)[-1]))\n}\n\nCheck Your Result\n\nrevenues &lt;- c(\"Elite\" = 100000, \"Premium\" = 250000)\nvar_cost &lt;- c(\"Elite\" = 70000, \"Premium\" = 120000)\n\ncm1 &lt;- subtract_cost(revenues, var_cost)\n\n\ncheck_named_vector(cm1, c(\"Elite\" = 30000, \"Premium\" = 130000))\n\nSuccess: Correct Values and Names"
  },
  {
    "objectID": "exercises/day1.html#task-4b-writing-a-formula-to-read-product-revenues",
    "href": "exercises/day1.html#task-4b-writing-a-formula-to-read-product-revenues",
    "title": "Day 1 - Building a Performance Measure Case",
    "section": "Task 4B: Writing a formula to read product revenues",
    "text": "Task 4B: Writing a formula to read product revenues\nObjective: For this task, your goal is to write a function named filter_revenue_input This function should return a named numeric vector where names are products, and values are the associated costs.\nYOUR FUNCTION:\n\nfilter_revenue_input &lt;- function(.tab, .type, .dep) {\n  # YOUR CODE HERE\n}\n\n\nfilter_revenue_input &lt;- function(.tab) {\n  .tab %&gt;%\n    dplyr::arrange(product) %&gt;%\n    dplyr::mutate(amount = purrr::set_names(amount, product)) %&gt;%\n    dplyr::pull(amount)\n}\n\n\nfilter_revenue_input(tab_revenue)\n\n  Elite Premium \n 250000  112500"
  },
  {
    "objectID": "exercises/day1.html#task-4c-writing-formulas-to-get-contribution-margin-list",
    "href": "exercises/day1.html#task-4c-writing-formulas-to-get-contribution-margin-list",
    "title": "Day 1 - Building a Performance Measure Case",
    "section": "Task 4C: Writing formulas to get Contribution Margin List",
    "text": "Task 4C: Writing formulas to get Contribution Margin List\nRemember Task 3B. Use the Functions subtract_cost() and sum_cost() to complete the get_cost_allocations_and_list() function.\n\nget_cost_allocation_and_cm_list &lt;- function(.tab_cost, .tab_revenue) {\n  lst_cost_ &lt;- get_cost_allocation_list(.tab_cost) # The Cost Allocation List\n  lst_cm_   &lt;- list() # A new List for Contribution Margin\n\n  lst_cm_[[\"revenues\"]] &lt;- filter_revenue_input(.tab_revenue) # Revenues\n  lst_cm_[[\"var_cost\"]] &lt;- NULL # YOUR CODE HERE    \n  lst_cm_[[\"cm1\"]]      &lt;- NULL # YOUR CODE HERE    \n  lst_cm_[[\"fix_cost\"]] &lt;- NULL # YOUR CODE HERE    \n  lst_cm_[[\"cm2\"]]      &lt;- NULL # YOUR CODE HERE    \n  \n  return(c(lst_cost_, lst_cm_)) # Return the combined list\n}\n\n\nget_cost_allocation_and_cm_list &lt;- function(.tab_cost, .tab_revenue) {\n  lst_cost_ &lt;- get_cost_allocation_list(.tab_cost)\n  lst_cm_   &lt;- list()\n\n  lst_cm_[[\"revenues\"]] &lt;- filter_revenue_input(.tab_revenue)\n  lst_cm_[[\"var_cost\"]] &lt;- sum_cost(lst_cost_$mat_dic, lst_cost_$man_dic)\n  lst_cm_[[\"cm1\"]]      &lt;- subtract_cost(lst_cm_$revenues, lst_cm_$var_cost)\n  lst_cm_[[\"fix_cost\"]] &lt;- sum_cost(lst_cost_$mat_alc, lst_cost_$man_alc, lst_cost_$adm_alc, lst_cost_$mar_alc)\n  lst_cm_[[\"cm2\"]]      &lt;- subtract_cost(lst_cm_$cm1, lst_cm_$fix_cost)\n  \n  return(c(lst_cost_, lst_cm_))\n}"
  },
  {
    "objectID": "exercises/day1.html#task-4d-display-contribution-margin-table",
    "href": "exercises/day1.html#task-4d-display-contribution-margin-table",
    "title": "Day 1 - Building a Performance Measure Case",
    "section": "Task 4D: Display Contribution Margin Table",
    "text": "Task 4D: Display Contribution Margin Table\nRemember Task 3C.\n\nget_contribution_margin_skeleton &lt;- function() {\n  tibble::tribble(\n    ~sign, ~var,\n    \" \", \"Revenue\",\n    \"-\", \"Variable Cost\",\n    \"=\", \"Contribution Margin 1\",\n    \"-\", \"Product Fix Cost\",\n    \"=\", \"Contribution Margin 2\",\n  )\n}\n\n\nmake_cm_table &lt;- function(.tab_cost, .tab_revenue) {\n  lst_cost_cm_ &lt;- get_cost_allocation_and_cm_list(.tab_cost, .tab_revenue)\n  lst_cm_ &lt;- lst_cost_cm_[c(\"revenues\", \"var_cost\", \"cm1\", \"fix_cost\", \"cm2\")]\n  \n  make_table_row &lt;- function(.vec) {\n    tibble::as_tibble(t(.vec))\n  }\n  \n  get_contribution_margin_skeleton() %&gt;%\n    dplyr::bind_cols(\n      dplyr::bind_rows(purrr::map(lst_cm_, make_table_row))\n      ) %&gt;%\n    dplyr::mutate(Total = rowSums(.[, -(1:2)]), .after = var)\n}\n\nformat_table(make_cm_table(tab_cost, tab_revenue))\n\n\n\n\n\n  \n    \n    \n      sign\n      var\n      Total\n      Elite\n      Premium\n    \n  \n  \n     \nRevenue\n362,500\n250,000\n112,500\n    -\nVariable Cost\n190,000\n70,000\n120,000\n    =\nContribution Margin 1\n172,500\n180,000\n(7,500)\n    -\nProduct Fix Cost\n284,500\n114,600\n169,900\n    =\nContribution Margin 2\n(112,000)\n65,400\n(177,400)"
  },
  {
    "objectID": "cv/index.html",
    "href": "cv/index.html",
    "title": "Curriculum vitae",
    "section": "",
    "text": "Download current CV"
  }
]