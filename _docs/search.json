[
  {
    "objectID": "projects/index.html",
    "href": "projects/index.html",
    "title": "Projects",
    "section": "",
    "text": "arXiv Preprint | Code\nOver the centuries, I have devoted countless hours to deciphering and translating the ancient scripts and dialects of the various peoples of Middle-earth. My goal is to gain a deeper understanding of the cultures and histories of these peoples by studying their languages. Currently, I am working on a monograph that explores the linguistic roots of the Elvish languages. Through extensive research and analysis, I hope to shed light on the connections between the different dialects of Elvish and their origins. This project has been particularly challenging, as Elvish is a complex and nuanced language, but I am determined to see it through to completion."
  },
  {
    "objectID": "projects/index.html#the-history-of-the-war-of-the-ring",
    "href": "projects/index.html#the-history-of-the-war-of-the-ring",
    "title": "Projects",
    "section": "The History of the War of the Ring",
    "text": "The History of the War of the Ring\n\narXiv Preprint | Code\nI am creating a comprehensive and detailed history of the conflict that goes beyond the surface-level events. By gathering information from a variety of sources, including my own memories, written accounts, and oral histories, I hope to shed new light on this important period in Middle-earth’s history and provide valuable insights into the motivations and actions of the various players involved.\n\nView the tutorial for this template (+ download link)"
  },
  {
    "objectID": "photography/index.html",
    "href": "photography/index.html",
    "title": "Photography",
    "section": "",
    "text": "As a wizard and scholar of Middle-earth, I have been studying the magic of the natural world for centuries. Through my self-portraits, I aim to capture the essence of my own being and reflect on my own journey through time. Each photograph is a reflection of my own experiences and emotions. Through my photography, I hope to offer a glimpse into my life as a scholar and adventurer, and inspire others to reflect on their own journeys through the world.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nView the tutorial for this template (+ download link)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "Introduction\nWelcome to the practical application sessions of the Mannheim Master in Management Analytics - Accounting Class 2024. In the next days you will see how to solve common business applications with R and Excel and to dive deeper into some research related application.\nThe goal of those sessions is to give you a general overview of how common workflows can be automated/streamlined.\nAll sessions are programmed in R and a basic understanding of programming is needed. The code itself applies relatively advanced methods, hence it is not assumed that you follow each single logical step. Rather this part of the course is designed to give you a high level understanding of what is possible using common open-source languages such as R.\n\n\n\nGet The Code\nThe complete code is hosted on my GitHub page: https://github.com/MatthiasUckert/RpMMA24\nSimply fork the repository into your own GitHub or download the Project.\n\n\n\nTable of Content\nYou can navigate to the individual sessions by either following the link in the table of contents, or by navigating through the drop-down menus at the top of the page.\n\n\n\n\n\n\n\n\nDay\nSession\nDescription\n\n\n\n\nDay 1\nSession 1\nBuilding an Excel Business Case\nIn this session we will start by building a simple business case in Excel. Specifically, we will evaluate a small business decision with common metrics such as Contribution Margins and Amortization Period.\n\n\nDay 2\nSession 1\nGetting Data from the Web: SEC’s EDGAR\nIn this session we will learn how the use the Electronic Data Gathering, Analysis, and Retrieval system (EDGAR) API to download US Financial Reports.\n\n\n\nSession 2\nGetting Data from the Web: www.AnnualReport.com\nIn this session we will learn how to scrape websites if no API is provided. Specifically we will download PDF Annual Reports from www.AnnualReport.com.\n\n\n\n\n\n\nInteresting Readings\n\nAdvanced R: https://adv-r.hadley.nz/\nR for Data Science: https://r4ds.had.co.nz/"
  },
  {
    "objectID": "cv/index.html",
    "href": "cv/index.html",
    "title": "Curriculum vitae",
    "section": "",
    "text": "Download current CV"
  },
  {
    "objectID": "html/test.html",
    "href": "html/test.html",
    "title": "Day 1 - Building a Business Case",
    "section": "",
    "text": "Introduction\nFoal of this lecture is to build a cost allocation and contribution margin model in R.\n\n\nLoading Libraries\n\nlibrary(tidyverse) \n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.3     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n# Includes: dplyr, readr, forcats, stringr, ggplot2, tibble, lubridate, tidyr, purrr\nlibrary(openxlsx)\n# Used for reading and writing excel sheets\nlibrary(janitor)\n\n\nAttaching package: 'janitor'\n\nThe following objects are masked from 'package:stats':\n\n    chisq.test, fisher.test\n\n# Used for cleaning data\nlibrary(scales)\n\n\nAttaching package: 'scales'\n\nThe following object is masked from 'package:purrr':\n\n    discard\n\nThe following object is masked from 'package:readr':\n\n    col_factor\n\n# Used for formatting number\nlibrary(tictoc)\n# \nlibrary(furrr)\n\nLoading required package: future\n\n# \n\noptions(scipen = 999)\nsource(\"additional_functions.R\")\nsc &lt;- scales::comma\n\n\n\n\nCost Overview\n\n\n\n\n\nCost Allocation\n\n\n\n\nFunction 1: Allocate Indirect Cost\nWe know that we have to allocate indirect costs onto the individual product. Let’s tale Material Cost as an example:\n\nDirect Cost Elite (DC1): 30,000 €\nDirect Cost Premium (DC2): 70,000 €\nIndirect Cost (IC): 40,000\n\nThe general Formula for allocating indirect Cost is:\n\\[\nIC_{c,i} = IC_{c}*\\frac{DC_{c,i}}{\\sum_{i} DC_i}\n\\]\nTask 01: Prepare the cost allocation for material\n\ncost_mat_dc &lt;- c(\"Elite\" = 30000, \"Premium\" = 70000)\ncost_mat_ic &lt;- 40000\n\nalloc_mat_ic &lt;- cost_mat_ic * (cost_mat_dc / sum(cost_mat_dc))\nalloc_mat_ic\n\n  Elite Premium \n  12000   28000 \n\n\nTask 02: Write a formula (allocate_indirect_cost) for cost allocation Make sure that the function only takes a named numeric vector as input (i.e. it throws an error if the vector is not numeric or not named) Naming convention: .m_dc (vector with multiple elements for direct cost) .s_ic (vector with a single elements for indirect cost)\n\nallocate_indirect_cost &lt;- function(.m_dc, .s_ic) {\n# YOUR CODE HERE\nif (!is.numeric(.m_dc)) stop(\".m_dc must be a numeric vector\", call. = FALSE)\nif (all(is.null(names(.m_dc)))) stop(\".m_dc must be a named vector\", call. = FALSE)\nif (any(names(.m_dc) == \"\")) stop(\"All elements of .m_dc must be named\", call. = FALSE)\n.m_dc * (.s_ic / sum(.m_dc))\n}\n\n\nalloc_mat_ic &lt;- allocate_indirect_cost(cost_mat_dc, cost_mat_ic)\n\nCheck\n\nalloc_mat_ic == c(\"Elite\" = 12000, \"Premium\" = 28000)\n\n  Elite Premium \n   TRUE    TRUE \n\nnames(alloc_mat_ic) == c(\"Elite\" = \"Elite\", \"Premium\" =  \"Premium\")\n\n  Elite Premium \n   TRUE    TRUE \n\n\nOne of the many nice thing in Accounting is, that you most of the time you only need the 4 arithmetical operators (+, -, *, / - In case you forgot them). Indeed, looking at the Cost Allocation Table we see that we only need one other Function, namely adding up the individual cost\nTask 03: Write a formula (sum_cost) for cost allocation Make sure that the function only takes a named numeric vector as input (i.e. it throws an error if the vector is not numeric or not named) The Function should take an arbitrary number of of named vectors (the cost vectors) and returns a the piece-wise sum of those elements. E.g. taking the cost vectors we calculated:\n\n`cost_mat_dc &lt;- c(“Elite” = 30000, “Premium” = 70000)`\n`alloc_mat_ic &lt;- c(“Elite” = 12000, “Premium” = 28000)`\n\nIt should return: `c(“Elite” = 42000, “Premium” = 98000)`\nUsing inputs of unknown lengths, can be accomplished in R in two separate ways:\n\nUsing a list: Put every single vector into a list element\nUsing the … operator: [PLEASE EXPLAIN]\n\n\nsum_cost &lt;- function(...) {\n  purrr::pmap_dbl(list(...), sum)\n}\n\ncost_mat_tot &lt;- sum_cost(cost_mat_dc, alloc_mat_ic )\n\nCheck\n\ncost_mat_tot == c(\"Elite\" = 42000, \"Premium\" = 98000)\n\n  Elite Premium \n   TRUE    TRUE \n\nnames(alloc_mat_ic) == c(\"Elite\" = \"Elite\", \"Premium\" =  \"Premium\")\n\n  Elite Premium \n   TRUE    TRUE \n\n\nWith those two functions we already have all the inputs we need to calculate a cost allocation table, but using vectors directly in R is somewhat cumbersome. In most cases you will get your data directly from your Ressource Planning System [INSERT CORRECT NAME]. See Excel Sheet\n\ntab_cost &lt;- tibble::as_tibble(\n  openxlsx::read.xlsx(\"../Business Case.xlsx\", \"Cost1\")\n  ) %&gt;%\n  janitor::clean_names() %&gt;%\n  dplyr::mutate(amount = purrr::set_names(amount, product))\ntab_cost\n\n# A tibble: 9 × 6\n  type     product department    amount distr   range_std\n  &lt;chr&gt;    &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;\n1 Direct   Elite   Material       30000 normal       5000\n2 Direct   Premium Material       70000 normal       7500\n3 Indirect &lt;NA&gt;    Material       40000 uniform      5000\n4 Direct   Elite   Manufacturing  40000 normal       2500\n5 Direct   Premium Manufacturing  50000 normal       1500\n6 Indirect &lt;NA&gt;    Manufacturing 135000 uniform     25000\n7 Indirect &lt;NA&gt;    Admin          73000 uniform      7500\n8 Indirect &lt;NA&gt;    Marketing      36500 uniform      3750\n9 Company  &lt;NA&gt;    &lt;NA&gt;           30000 uniform     22500\n\ntab_cost$amount\n\n  Elite Premium    &lt;NA&gt;   Elite Premium    &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt; \n  30000   70000   40000   40000   50000  135000   73000   36500   30000 \n\n\nTask 04: Using the Excel sheet (Cost1), write a function that filters for a specific cost type (i.e. Direct or Indirect) and a specific Cost Department (e.g. Material) and returns a named numeric vector (names are the products and the values are the associated cost)\n\nfilter_cost_input &lt;- function(.tab, .type, .dep) {\n .tab %&gt;%\n   dplyr::filter(type == .type, department == .dep) %&gt;%\n   dplyr::arrange(product) %&gt;%\n   dplyr::pull(amount)\n}\n\nfilter_cost_input(tab_cost, \"Direct\", \"Material\")\n\n  Elite Premium \n  30000   70000 \n\n\nallocate_indirect_cost()\n\nsum_cost()\nfilter_cost_input()\n\n\nget_cost_allocations &lt;- function(.tab_cost) {\n  lst_ &lt;- list()\n\n  lst_[[\"dir_mat_cost\"]] &lt;- filter_cost_input(.tab_cost, \"Direct\", \"Material\")\n\n  lst_[[\"ind_mat_cost\"]] &lt;- filter_cost_input(.tab_cost, \"Indirect\", \"Material\")\n\n  lst_[[\"all_mat_cost\"]] &lt;- allocate_indirect_cost(lst_$dir_mat_cost, lst_$ind_mat_cost)\n\n  lst_[[\"sum_mat_cost\"]] &lt;- sum_cost(lst_$dir_mat_cost, lst_$all_mat_cost)\n\n  lst_[[\"dir_man_cost\"]] &lt;- filter_cost_input(.tab_cost, \"Direct\", \"Manufacturing\")\n\n  lst_[[\"ind_man_cost\"]] &lt;- filter_cost_input(.tab_cost, \"Indirect\", \"Manufacturing\")\n\n  lst_[[\"all_man_cost\"]] &lt;- allocate_indirect_cost(lst_$dir_man_cost, lst_$ind_man_cost)\n\n  lst_[[\"sum_man_cost\"]] &lt;- sum_cost(lst_$sum_mat_cost, lst_$dir_man_cost, lst_$all_man_cost)\n\n  lst_[[\"ind_adm_cost\"]] &lt;- filter_cost_input(.tab_cost, \"Indirect\", \"Admin\")\n\n  lst_[[\"all_adm_cost\"]] &lt;- allocate_indirect_cost(lst_$sum_man_cost, lst_$ind_adm_cost)\n\n  lst_[[\"ind_mar_cost\"]] &lt;- filter_cost_input(.tab_cost, \"Indirect\", \"Marketing\")\n\n  lst_[[\"all_mar_cost\"]] &lt;- allocate_indirect_cost(lst_$sum_man_cost, lst_$ind_mar_cost)\n\n  lst_[[\"tot_prd_cost\"]] &lt;- sum_cost(lst_$sum_man_cost, lst_$all_adm_cost, lst_$all_mar_cost)\n\n  return(lst_)\n}\n\nget_cost_allocation_skeleton &lt;- function() {\n  tibble::tribble(\n    ~sign, ~var,\n    \" \", \"Direct Material Costs\",\n    \"+\", \"Indirect Material Costs\",\n    \"=\", \"Material Costs\",\n    \"+\", \"Direct Manufacturing Costs\",\n    \"+\", \"Indirect Manufacturing Costs\",\n    \"=\", \"Manufacturing Costs\",\n    \"+\", \"Indirect Administration Costs\",\n    \"+\", \"Indirect Marketing Costs\",\n    \"=\", \"Total Product Costs\"\n  )\n}\n\n\nget_cost_allocations(tab_cost)\n\n$dir_mat_cost\n  Elite Premium \n  30000   70000 \n\n$ind_mat_cost\n &lt;NA&gt; \n40000 \n\n$all_mat_cost\n  Elite Premium \n  12000   28000 \n\n$sum_mat_cost\n  Elite Premium \n  42000   98000 \n\n$dir_man_cost\n  Elite Premium \n  40000   50000 \n\n$ind_man_cost\n  &lt;NA&gt; \n135000 \n\n$all_man_cost\n  Elite Premium \n  60000   75000 \n\n$sum_man_cost\n  Elite Premium \n 142000  223000 \n\n$ind_adm_cost\n &lt;NA&gt; \n73000 \n\n$all_adm_cost\n  Elite Premium \n  28400   44600 \n\n$ind_mar_cost\n &lt;NA&gt; \n36500 \n\n$all_mar_cost\n  Elite Premium \n  14200   22300 \n\n$tot_prd_cost\n  Elite Premium \n 184600  289900 \n\nget_cost_allocation_skeleton()\n\n# A tibble: 9 × 2\n  sign  var                          \n  &lt;chr&gt; &lt;chr&gt;                        \n1 \" \"   Direct Material Costs        \n2 \"+\"   Indirect Material Costs      \n3 \"=\"   Material Costs               \n4 \"+\"   Direct Manufacturing Costs   \n5 \"+\"   Indirect Manufacturing Costs \n6 \"=\"   Manufacturing Costs          \n7 \"+\"   Indirect Administration Costs\n8 \"+\"   Indirect Marketing Costs     \n9 \"=\"   Total Product Costs          \n\n\nTask 05: Using the functions: get_cost_allocations() and get_cost_allocation_skeleton(), replicate the Cost Allocation Table\nToDO so please write a function: make_cost_allocation_table()\n\n.tab_cost &lt;- tab_cost\nmake_cost_allocation_table &lt;- function(.tab_cost) {\n  lst_cost_ &lt;- get_cost_allocations(.tab_cost)\n  lst_cost_ &lt;- lst_cost_[c(\n    \"dir_mat_cost\", \"all_mat_cost\", \"sum_mat_cost\", \"dir_man_cost\",\n    \"all_man_cost\", \"sum_man_cost\", \"all_adm_cost\", \"all_mar_cost\", \"tot_prd_cost\"\n  )]\n  \n  make_table_row &lt;- function(.vec) {\n    tibble::as_tibble(t(.vec))\n  }\n  \n  get_cost_allocation_skeleton() %&gt;%\n    dplyr::bind_cols(\n      dplyr::bind_rows(purrr::map(lst_cost_, make_table_row))\n      ) %&gt;%\n    dplyr::mutate(Total = rowSums(.[, -(1:2)]), .after = var)\n}\n\n\nformat_table(make_cost_allocation_table(tab_cost))\n\n\n\n\n\n  \n    \n    \n      sign\n      var\n      Total\n      Elite\n      Premium\n    \n  \n  \n     \nDirect Material Costs\n100,000\n30,000\n70,000\n    +\nIndirect Material Costs\n40,000\n12,000\n28,000\n    =\nMaterial Costs\n140,000\n42,000\n98,000\n    +\nDirect Manufacturing Costs\n90,000\n40,000\n50,000\n    +\nIndirect Manufacturing Costs\n135,000\n60,000\n75,000\n    =\nManufacturing Costs\n365,000\n142,000\n223,000\n    +\nIndirect Administration Costs\n73,000\n28,400\n44,600\n    +\nIndirect Marketing Costs\n36,500\n14,200\n22,300\n    =\nTotal Product Costs\n474,500\n184,600\n289,900\n  \n  \n  \n\n\n\n\n\n\nContribution Margin\nHaving the cost allocation ready, we no focus on performance measures, namely the contribution margin. Looking at the Contribution margin table we see that we now need another function, namely where we have one positive input value (e.g. revenue) and subtract a cost element (e.g. Variable Cost)\n\ntab_revenue &lt;- tibble::as_tibble(\n  openxlsx::read.xlsx(\"../Business Case.xlsx\", \"Revenue1\")\n  ) %&gt;%\n  janitor::clean_names() %&gt;%\n  dplyr::mutate(amount = purrr::set_names(amount, product))\ntab_revenue\n\n# A tibble: 2 × 6\n  product units price amount distr  range_std\n  &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt;\n1 Elite     500   500 250000 normal     25000\n2 Premium   150   750 112500 normal     10000\n\ntab_revenue$amount\n\n  Elite Premium \n 250000  112500 \n\n\nTask 05: Write a function (subtract_cost) that takes two named vectors as input (.m_init, .m_cost)\n\nsubtract_cost &lt;- function(...) {\n  purrr::pmap_dbl(list(...), ~ sum(c(...)[1], -c(...)[-1]))\n}\n\n\nrevenues &lt;- c(\"Elite\" = 100000, \"Premium\" = 250000)\nvar_cost &lt;- c(\"Elite\" = 70000, \"Premium\" = 120000)\n\ncm1 &lt;- subtract_cost(revenues, var_cost)\n\ncm1 == c(\"Elite\" = 30000, \"Premium\" = 130000)\n\n  Elite Premium \n   TRUE    TRUE \n\nnames(alloc_mat_ic) == c(\"Elite\" = \"Elite\", \"Premium\" =  \"Premium\")\n\n  Elite Premium \n   TRUE    TRUE \n\n\n\nfilter_revenue_input &lt;- function(.tab) {\n  .tab %&gt;%\n    dplyr::arrange(product) %&gt;%\n    dplyr::pull(amount)\n}\n\n.tab_cost &lt;- tab_cost\n.tab_revenue &lt;- tab_revenue\n\nget_cost_allocation_and_cm &lt;- function(.tab_cost, .tab_revenue) {\n  lst_cost_ &lt;- get_cost_allocations(.tab_cost)\n  lst_cm_ &lt;- list()\n\n\n  lst_cm_[[\"revenues\"]] &lt;- filter_revenue_input(.tab_revenue)\n\n  lst_cm_[[\"var_cost\"]] &lt;- sum_cost(lst_cost_$dir_mat_cost, lst_cost_$dir_man_cost)\n\n  lst_cm_[[\"cm1\"]] &lt;- subtract_cost(lst_cm_$revenues, lst_cm_$var_cost)\n\n  lst_cm_[[\"fix_cost\"]] &lt;- sum_cost(\n    lst_cost_$all_mat_cost, lst_cost_$all_man_cost, lst_cost_$all_adm_cost, lst_cost_$all_mar_cost\n  )\n\n  lst_cm_[[\"cm2\"]] &lt;- subtract_cost(lst_cm_$cm1, lst_cm_$fix_cost)\n  \n  \n  return(c(lst_cost_, lst_cm_))\n}\n\nget_contribution_margin_skeleton &lt;- function() {\n  tibble::tribble(\n    ~sign, ~var,\n    \" \", \"Revenue\",\n    \"-\", \"Variable Cost\",\n    \"=\", \"Contribution Margin 1\",\n    \"-\", \"Product Fix Cost\",\n    \"=\", \"Contribution Margin 2\",\n  )\n}\n\nmake_cm_table &lt;- function(.tab_cost, .tab_revenue) {\n  lst_cost_cm_ &lt;- get_cost_allocation_and_cm(.tab_cost, .tab_revenue)\n  lst_cm_ &lt;- lst_cost_cm_[c(\"revenues\", \"var_cost\", \"cm1\", \"fix_cost\", \"cm2\")]\n  \n  make_table_row &lt;- function(.vec) {\n    tibble::as_tibble(t(.vec))\n  }\n  \n  get_contribution_margin_skeleton() %&gt;%\n    dplyr::bind_cols(\n      dplyr::bind_rows(purrr::map(lst_cm_, make_table_row))\n      ) %&gt;%\n    dplyr::mutate(Total = rowSums(.[, -(1:2)]), .after = var)\n}\n\nformat_table(make_cm_table(tab_cost, tab_revenue))\n\n\n\n\n\n  \n    \n    \n      sign\n      var\n      Total\n      Elite\n      Premium\n    \n  \n  \n     \nRevenue\n362,500\n250,000\n112,500\n    -\nVariable Cost\n190,000\n70,000\n120,000\n    =\nContribution Margin 1\n172,500\n180,000\n(7,500)\n    -\nProduct Fix Cost\n284,500\n114,600\n169,900\n    =\nContribution Margin 2\n(112,000)\n65,400\n(177,400)\n  \n  \n  \n\n\n\n\n\n\nMonte Carlo Analysis\nNow that we have all relevant inputs, we can move to a topic that is increasingly harder to implement in Excel, namely a Monet Carlo Analysis. In essence a Monte Carlo Analysis randomizes specific Inputs according to a random distribution and shows the effect on an outcome variable, e.g. A Contribution margin.\nSince we are already able to calculate all necessary inputs for a contribution margin analysis, the only thing that is left is to be able to randomize our inputs.\n\nrandomize_input &lt;- function(.distr, .mean, .bound, .seed) {\n  set.seed(.seed)\n  if (.distr == \"normal\") {\n    rnorm(1, .mean, .bound)\n  } else if (.distr == \"uniform\") {\n    runif(1, .mean - .bound, .mean + .bound)\n  } else {\n    stop(\"Wrong Distribution Specified\")\n  }\n}\n\nrandomize_input_table &lt;- function(.tab, .seed) {\n  .tab %&gt;%\n    dplyr::mutate(\n      amount = purrr::pmap_dbl(\n        .l = list(distr, amount, range_std), \n        .f = ~ randomize_input(..1, ..2, ..3, .seed)\n        )) %&gt;%\n    dplyr::mutate(amount = purrr::set_names(amount, product))\n}\n\n\n\nrandomize_input(tab_cost$distr[1], tab_cost$amount[1], tab_cost$range_std[1], 1)\n\n[1] 26867.73\n\nrandomize_input_table(.tab = tab_revenue, 2)\n\n# A tibble: 2 × 6\n  product units price  amount distr  range_std\n  &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt;\n1 Elite     500   500 227577. normal     25000\n2 Premium   150   750 103531. normal     10000\n\n\n\nmake_cm_table(\n  .tab_cost = randomize_input_table(tab_cost, 2), \n  .tab_revenue = randomize_input_table(tab_revenue, 2)\n  ) %&gt;%  format_table()\n\n\n\n\n\n  \n    \n    \n      sign\n      var\n      Total\n      Elite\n      Premium\n    \n  \n  \n     \nRevenue\n331,108\n227,577\n103,531\n    -\nVariable Cost\n175,201\n63,273\n111,928\n    =\nContribution Margin 1\n155,907\n164,304\n(8,397)\n    -\nProduct Fix Cost\n258,503\n101,632\n156,871\n    =\nContribution Margin 2\n(102,596)\n62,672\n(165,268)\n  \n  \n  \n\n\n\n\n\ntictoc::tic()\nlst_monte_carlo &lt;- purrr::map(\n  .x = 1:1000,\n  .f = ~ get_cost_allocation_and_cm(\n    .tab_cost = randomize_input_table(tab_cost, .x),\n    .tab_revenue = randomize_input_table(tab_revenue, .x)\n  ), .progress = TRUE\n)\n\n ■■■                                6% |  ETA: 27s\n\n\n ■■■■■■                            16% |  ETA: 25s\n\n\n ■■■■■■■■■                         27% |  ETA: 21s\n\n\n ■■■■■■■■■■■■                      37% |  ETA: 18s\n\n\n ■■■■■■■■■■■■■■■                   48% |  ETA: 15s\n\n\n ■■■■■■■■■■■■■■■■■■■               59% |  ETA: 12s\n\n\n ■■■■■■■■■■■■■■■■■■■■■■            69% |  ETA:  9s\n\n\n ■■■■■■■■■■■■■■■■■■■■■■■■■         79% |  ETA:  6s\n\n\n ■■■■■■■■■■■■■■■■■■■■■■■■■■■■      89% |  ETA:  3s\n\n\n ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■    98% |  ETA:  1s\n\ntictoc::toc()\n\n29.31 sec elapsed\n\n\n\ntab_cost\n\n# A tibble: 9 × 6\n  type     product department    amount distr   range_std\n  &lt;chr&gt;    &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;\n1 Direct   Elite   Material       30000 normal       5000\n2 Direct   Premium Material       70000 normal       7500\n3 Indirect &lt;NA&gt;    Material       40000 uniform      5000\n4 Direct   Elite   Manufacturing  40000 normal       2500\n5 Direct   Premium Manufacturing  50000 normal       1500\n6 Indirect &lt;NA&gt;    Manufacturing 135000 uniform     25000\n7 Indirect &lt;NA&gt;    Admin          73000 uniform      7500\n8 Indirect &lt;NA&gt;    Marketing      36500 uniform      3750\n9 Company  &lt;NA&gt;    &lt;NA&gt;           30000 uniform     22500"
  },
  {
    "objectID": "html/test.html#running-code",
    "href": "html/test.html#running-code",
    "title": "Untitled",
    "section": "Running Code",
    "text": "Running Code\nWhen you click the Render button a document will be generated that includes both content and the output of embedded code. You can embed code like this:\n\nlibrary(tidyverse)\n\n-- Attaching packages --------------------------------------- tidyverse 1.3.1 --\n\n\nv ggplot2 3.3.5     v purrr   1.0.1\nv tibble  3.2.1     v dplyr   1.1.1\nv tidyr   1.3.0     v stringr 1.5.0\nv readr   2.1.2     v forcats 0.5.1\n\n\nWarning: package 'tibble' was built under R version 4.1.3\n\n\nWarning: package 'tidyr' was built under R version 4.1.3\n\n\nWarning: package 'purrr' was built under R version 4.1.3\n\n\nWarning: package 'dplyr' was built under R version 4.1.3\n\n\nWarning: package 'stringr' was built under R version 4.1.3\n\n\n-- Conflicts ------------------------------------------ tidyverse_conflicts() --\nx dplyr::filter() masks stats::filter()\nx dplyr::lag()    masks stats::lag()\n\n\nYou can add options to executable code like this\n\n\n[1] 4\n\n\nThe echo: false option disables the printing of code (only output is displayed).\n\n.m_cost = c(30000, 70000)\n.s_indirect_cost = 40000\n\ncalc_indirect_..._cost <- function(.m_cost, .s_indirect_cost) {\n  .m_cost * (.s_indirect_cost / sum(.m_cost))\n}\n\ncalc_sum_cost <- function(...) {\n  purrr::pmap_dbl(list(...), sum)\n}\n\ncalc_diff_cost <- function(...) {\n  purrr::pmap_dbl(list(...), ~ sum(c(...)[1], -c(...)[-1]))\n}\n\nmake_table_row <- function(.vec) {\n  purrr::set_names(tibble::as_tibble(t(tibble::tibble(.vec))), names(.vec))\n}\n\n\n(direct_material_cost <- c(A = 30000, B =  70000))\n\n    A     B \n30000 70000 \n\nindirect_material_cost <- 40000\n\n(allocated_indirect_material_cost <- calc_indirect_..._cost(direct_material_cost, indirect_material_cost))\n\n    A     B \n12000 28000 \n\n(material_cost <- calc_sum_cost(direct_material_cost, allocated_indirect_material_cost))\n\n    A     B \n42000 98000 \n\n(direct_manufacturing_cost <- c(A = 40000, B = 50000))\n\n    A     B \n40000 50000 \n\nindirect_manufacturing_cost <- 135000\n\n(allocated_indirect_manufacturing_cost <- calc_indirect_..._cost(direct_manufacturing_cost, indirect_manufacturing_cost))\n\n    A     B \n60000 75000 \n\n(manufacturing_cost <- calc_sum_cost(material_cost, direct_manufacturing_cost, allocated_indirect_manufacturing_cost))\n\n     A      B \n142000 223000 \n\nindirect_admin_cost <- 73000\n(allocated_indirect_admin_cost <- calc_indirect_..._cost(manufacturing_cost, indirect_admin_cost))\n\n    A     B \n28400 44600 \n\nindirect_marketing_cost <- 36500\n(allocated_indirect_marketing_cost <- calc_indirect_..._cost(manufacturing_cost, indirect_marketing_cost))\n\n    A     B \n14200 22300 \n\n(total_product_cost <- calc_sum_cost(manufacturing_cost, allocated_indirect_marketing_cost, allocated_indirect_admin_cost))\n\n     A      B \n184600 289900 \n\n\n\ntab_cost_ <- tibble::tribble(\n  ~sign, ~cost,\n  \" \", \"Direct Material Costs\",\n  \n  \"+\", \"Indirect Material Costs\",\n  \"=\", \"Material Costs\",\n  \n  \"+\", \"Direct Manufacturing Costs\",\n  \"+\", \"Indirect Manufacturing Costs\",\n  \"=\", \"Manufacturing Costs\",\n  \n  \"+\", \"Indirect Administration Costs\",\n  \"+\", \"Indirect Marketing Costs\",\n  \"=\", \"Total Product Costs\"\n) %>% dplyr::bind_cols(\n  dplyr::bind_rows(\n    make_table_row(direct_material_cost),\n    make_table_row(allocated_indirect_material_cost),\n    make_table_row(material_cost),\n    make_table_row(direct_manufacturing_cost),\n    make_table_row(allocated_indirect_manufacturing_cost),\n    make_table_row(manufacturing_cost),\n    make_table_row(allocated_indirect_admin_cost),\n    make_table_row(allocated_indirect_marketing_cost),\n    make_table_row(total_product_cost),\n  )\n)\n\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\ni Using compatibility `.name_repair`.\n\n\n\nrevenues <- c(A = 100000, B = 250000)\nvariable_cost <- calc_sum_cost(direct_material_cost, direct_manufacturing_cost)\ncm1 <- calc_diff_cost(revenues, variable_cost)\nproduct_fix_cost <- calc_sum_cost(allocated_indirect_admin_cost, allocated_indirect_manufacturing_cost, allocated_indirect_marketing_cost, allocated_indirect_material_cost)\ncm2 <- calc_diff_cost(cm1, product_fix_cost)\n\n\ntab_cm_ <- tibble::tribble(\n  ~sign, ~cost,\n  \" \", \"Revenue\",\n  \n  \"-\", \"Variable Cost\",\n  \"=\", \"Contribution Margin 1\",\n  \n  \"-\", \"Product Fix Cost\",\n  \"=\", \"Contribution Margin 2\",\n  \n  # \"-\", \"Company Fix Cost\",\n  # \"=\", \"Profit\"\n) %>% dplyr::bind_cols(\n  dplyr::bind_rows(\n    make_table_row(revenues),\n    make_table_row(variable_cost),\n    make_table_row(cm1),\n    make_table_row(product_fix_cost),\n    make_table_row(cm2)\n  )\n) %>% dplyr::mutate(Total = rowSums(.[, -(1:2)]), .after = cost) \ntab_cm_\n\n# A tibble: 5 x 5\n  sign  cost                    Total      A      B\n  <chr> <chr>                   <dbl>  <dbl>  <dbl>\n1 \" \"   Revenue                350000 100000 250000\n2 \"-\"   Variable Cost          190000  70000 120000\n3 \"=\"   Contribution Margin 1  160000  30000 130000\n4 \"-\"   Product Fix Cost       284500 114600 169900\n5 \"=\"   Contribution Margin 2 -124500 -84600 -39900\n\n\n\nfilter_cost_input <- function(.tab, .type, .dep) {\n  .tab %>%\n    dplyr::filter(type == .type, department == .dep) %>%\n    dplyr::arrange(product) %>%\n    dplyr::pull(amount)\n}\n\nfilter_revenue_input <- function(.tab) {\n  .tab %>%\n    dplyr::arrange(product) %>%\n    dplyr::pull(revenue)\n}\n\n.path <- \"../Business Case.xlsx\"\n\nmake_tables <- function(.path) {\n  cost_ <- openxlsx::read.xlsx(.path, \"Cost\") %>%\n    janitor::clean_names() %>%\n    dplyr::select(type, product, department, amount) %>%\n    dplyr::filter(!type == \"Total\") %>%\n    dplyr::mutate(amount = purrr::set_names(amount, product)) %>%\n    dplyr::arrange()\n\n  revenue_ <- openxlsx::read.xlsx(.path, \"Revenue\") %>%\n    janitor::clean_names() %>%\n    dplyr::select(product, units, price, revenue) %>%\n    dplyr::filter(!product == \"Total\") %>%\n    dplyr::mutate(revenue = purrr::set_names(revenue, product))\n\n\n  dir_mat_cost <- filter_cost_input(cost_, \"Direct\", \"Material\")\n  ind_mat_cost <- filter_cost_input(cost_, \"Indirect\", \"Material\")\n\n  all_mat_cost <- calc_indirect_..._cost(dir_mat_cost, ind_mat_cost)\n  sum_mat_cost <- calc_sum_cost(dir_mat_cost, all_mat_cost)\n\n  dir_man_cost <- filter_cost_input(cost_, \"Direct\", \"Manufacturing\")\n  ind_man_cost <- filter_cost_input(cost_, \"Indirect\", \"Manufacturing\")\n  all_man_cost <- calc_indirect_..._cost(dir_man_cost, ind_man_cost)\n  sum_man_cost <- calc_sum_cost(sum_mat_cost, dir_man_cost, all_man_cost)\n\n  ind_adm_cost <- filter_cost_input(cost_, \"Indirect\", \"Admin\")\n  all_adm_cost <- calc_indirect_..._cost(sum_man_cost, ind_adm_cost)\n\n  ind_mar_cost <- filter_cost_input(cost_, \"Indirect\", \"Marketing\")\n  all_mar_cost <- calc_indirect_..._cost(sum_man_cost, ind_mar_cost)\n\n  tot_prd_cost <- calc_sum_cost(sum_man_cost, all_adm_cost, all_mar_cost)\n\n\n  out_cost_ <- tibble::tribble(\n    ~sign, ~var,\n    \" \", \"Direct Material Costs\",\n    \"+\", \"Indirect Material Costs\",\n    \"=\", \"Material Costs\",\n    \"+\", \"Direct Manufacturing Costs\",\n    \"+\", \"Indirect Manufacturing Costs\",\n    \"=\", \"Manufacturing Costs\",\n    \"+\", \"Indirect Administration Costs\",\n    \"+\", \"Indirect Marketing Costs\",\n    \"=\", \"Total Product Costs\"\n  ) %>%\n    dplyr::bind_cols(\n      dplyr::bind_rows(\n        make_table_row(dir_mat_cost),\n        make_table_row(all_mat_cost),\n        make_table_row(sum_mat_cost),\n        make_table_row(dir_man_cost),\n        make_table_row(all_man_cost),\n        make_table_row(sum_man_cost),\n        make_table_row(all_adm_cost),\n        make_table_row(all_mar_cost),\n        make_table_row(tot_prd_cost),\n      )\n    ) %>%\n    dplyr::mutate(Total = rowSums(.[, -(1:2)]), .after = var)\n\n  \n  revenues <- filter_revenue_input(revenue_)\n  var_cost <- calc_sum_cost(dir_mat_cost, dir_man_cost)\n  cm1 <- calc_diff_cost(revenues, var_cost)\n  fix_cost <- calc_sum_cost(all_mat_cost, all_man_cost, all_adm_cost, all_mar_cost)\n  cm2 <- calc_diff_cost(cm1, fix_cost)\n\n\n  out_cm_ <- tibble::tribble(\n    ~sign, ~var,\n    \" \", \"Revenue\",\n    \"-\", \"Variable Cost\",\n    \"=\", \"Contribution Margin 1\",\n    \"-\", \"Product Fix Cost\",\n    \"=\", \"Contribution Margin 2\",\n\n    # \"-\", \"Company Fix Cost\",\n    # \"=\", \"Profit\"\n  ) %>%\n    dplyr::bind_cols(\n      dplyr::bind_rows(\n        make_table_row(revenues),\n        make_table_row(var_cost),\n        make_table_row(cm1),\n        make_table_row(fix_cost),\n        make_table_row(cm2)\n      )\n    ) %>%\n    dplyr::mutate(Total = rowSums(.[, -(1:2)]), .after = var)\n  \n  return(list(cost = out_cost_, cm = out_cm_))\n}\n\nformat_table <- function(.tab) {\n  cols_format <- colnames(.tab)\n  cols_format <- cols_format[!cols_format %in% c(\"sign\", \"var\")]\n  \n  gt_table <- gt::gt(.tab)\n  \n  # Making the header bold\n  gt_table <- gt_table %>%\n    gt::tab_style(\n      style = list(\n        gt::cell_text(weight = \"bold\")\n      ),\n      locations = list(\n        gt::cells_column_labels(columns = everything())\n      )\n    )\n  \n  # Making rows with \"=\" and empty sign bold\n  gt_table <- gt_table %>%\n    gt::tab_style(\n      style = list(\n        gt::cell_text(weight = \"bold\")\n      ),\n      locations = list(\n        gt::cells_body(\n          rows = which(.tab$sign %in% c(\"=\", \"\")),\n          columns = gt::everything()\n        )\n      )\n    )\n  \n  # Making negative values red\n  for(col in cols_format) {\n    gt_table <- gt_table %>%\n      gt::tab_style(\n        style = list(\n          gt::cell_text(color = \"red\")\n        ),\n        locations = list(\n          gt::cells_body(\n            columns = col,\n            rows = which(.tab[[col]] < 0)\n          )\n        )\n      )\n  }\n  \n  # Formatting numbers\n  gt_table <- gt_table %>%\n    gt::fmt_number(\n      columns = cols_format,\n      decimals = 0,\n      use_seps = TRUE,\n      accounting = TRUE\n    )\n  \n  return(gt_table)\n}\n\n\n\n\nlst_ <- make_tables(\"../Business Case.xlsx\")\n\nformat_table(lst_$cost)\n\nWarning: Using an external vector in selections was deprecated in tidyselect 1.1.0.\ni Please use `all_of()` or `any_of()` instead.\n  # Was:\n  data %>% select(col)\n\n  # Now:\n  data %>% select(all_of(col))\n\nSee <https://tidyselect.r-lib.org/reference/faq-external-vector.html>.\n\n\nWarning: Using an external vector in selections was deprecated in tidyselect 1.1.0.\ni Please use `all_of()` or `any_of()` instead.\n  # Was:\n  data %>% select(cols_format)\n\n  # Now:\n  data %>% select(all_of(cols_format))\n\nSee <https://tidyselect.r-lib.org/reference/faq-external-vector.html>.\n\n\n\n\n\n\n\nsign\n      var\n      Total\n      Elite\n      Light\n      Premium\n    \n\n\n \nDirect Material Costs\n115,000\n30,000\n15,000\n70,000\n\n\n+\nIndirect Material Costs\n40,000\n10,435\n5,217\n24,348\n\n\n=\nMaterial Costs\n155,000\n40,435\n20,217\n94,348\n\n\n+\nDirect Manufacturing Costs\n120,000\n40,000\n30,000\n50,000\n\n\n+\nIndirect Manufacturing Costs\n135,000\n45,000\n33,750\n56,250\n\n\n=\nManufacturing Costs\n410,000\n125,435\n83,967\n200,598\n\n\n+\nIndirect Administration Costs\n73,000\n22,334\n14,950\n35,716\n\n\n+\nIndirect Marketing Costs\n36,500\n11,167\n7,475\n17,858\n\n\n=\nTotal Product Costs\n519,500\n158,935\n106,393\n254,172\n\n\n\n\n\nformat_table(lst_$cm)\n\n\n\n\n\n\nsign\n      var\n      Total\n      Elite\n      Light\n      Premium\n    \n\n\n \nRevenue\n712,500\n250,000\n350,000\n112,500\n\n\n-\nVariable Cost\n235,000\n70,000\n45,000\n120,000\n\n\n=\nContribution Margin 1\n477,500\n180,000\n305,000\n(7,500)\n\n\n-\nProduct Fix Cost\n284,500\n88,935\n61,393\n134,172\n\n\n=\nContribution Margin 2\n193,000\n91,065\n243,607\n(141,672)"
  },
  {
    "objectID": "exercises/day1.html",
    "href": "exercises/day1.html",
    "title": "Day 1 - Building a Performance Measure Case",
    "section": "",
    "text": "Today’s complex business environment demands tools that offer both versatility and precision. In this session, we’ll explore three vital financial tasks using the R programming environment:\n\nCost Allocation: Get a granular understanding of how costs disperse across products, emphasizing the allocation of indirect costs.\nContribution Margin Analysis: Examine the profitability of individual products, distinguishing which products significantly impact the bottom line.\nMonte-Carlo Analysis: Navigate business uncertainties with this statistical technique, utilizing random sampling to achieve numerical results for multifaceted problems.\n\nBut why opt for R over mainstream tools like Excel?\nThe Case for R:\n\nReproducibility: With R scripts, analyses can be reproduced and validated effortlessly. This is invaluable for audits or simply revisiting your work months or years later.\nHandling Large Datasets: R is equipped to manage extensive datasets, something Excel struggles with beyond a point.\nFlexibility: R’s vast array of packages and its ability to integrate with other languages and tools make it highly adaptable.\nAdvanced Statistical Analysis: While Excel offers basic statistical tools, R provides a comprehensive suite for sophisticated analyses.\nCost-Effective: Being open-source, R is freely available, ensuring businesses don’t incur additional software costs.\n\nBy the session’s end, you’ll appreciate not just the theoretical aspects of these techniques but also the practical advantages of implementing them in an open-source environment like R.\nLet’s get started!"
  },
  {
    "objectID": "exercises/day1.html#data-manipulation-and-visualization",
    "href": "exercises/day1.html#data-manipulation-and-visualization",
    "title": "Day 1 - Building a Performance Measure Case",
    "section": "Data Manipulation and Visualization",
    "text": "Data Manipulation and Visualization\n\ntidyverse: A collection of packages tailored for data science.\n\nIncludes dplyr for data manipulation, ggplot2 for data visualization, readr for reading data, among others.\n\njanitor: Useful for cleaning data and performing some basic data wrangling tasks."
  },
  {
    "objectID": "exercises/day1.html#data-io",
    "href": "exercises/day1.html#data-io",
    "title": "Day 1 - Building a Performance Measure Case",
    "section": "Data I/O",
    "text": "Data I/O\n\nopenxlsx: Specifically designed for reading from and writing to Excel sheets."
  },
  {
    "objectID": "exercises/day1.html#numeric-and-statistical-functions",
    "href": "exercises/day1.html#numeric-and-statistical-functions",
    "title": "Day 1 - Building a Performance Measure Case",
    "section": "Numeric and Statistical Functions",
    "text": "Numeric and Statistical Functions\n\nscales: Aids in formatting numbers, especially for data visualization purposes.\nfurrr: An offshoot of the purrr package, furrr makes it easy to apply functions in parallel."
  },
  {
    "objectID": "exercises/day1.html#themes-and-visualization-enhancements",
    "href": "exercises/day1.html#themes-and-visualization-enhancements",
    "title": "Day 1 - Building a Performance Measure Case",
    "section": "Themes and Visualization Enhancements",
    "text": "Themes and Visualization Enhancements\n\nggthemes: Provides additional themes and scales for ggplot2, enhancing the aesthetics and readability of plots."
  },
  {
    "objectID": "exercises/day1.html#miscellaneous",
    "href": "exercises/day1.html#miscellaneous",
    "title": "Day 1 - Building a Performance Measure Case",
    "section": "Miscellaneous",
    "text": "Miscellaneous\n\ntictoc: Helps in measuring the time taken for code execution, useful for performance tuning."
  },
  {
    "objectID": "exercises/day1.html#custom-functions",
    "href": "exercises/day1.html#custom-functions",
    "title": "Day 1 - Building a Performance Measure Case",
    "section": "Custom Functions",
    "text": "Custom Functions\n\nsource(\"additional_functions.R\"): Loads user-defined functions from an external R script.\n\n\nlibrary(tidyverse)\n\n-- Attaching core tidyverse packages ------------------------ tidyverse 2.0.0 --\nv dplyr     1.1.2     v readr     2.1.4\nv forcats   1.0.0     v stringr   1.5.0\nv ggplot2   3.4.3     v tibble    3.2.1\nv lubridate 1.9.2     v tidyr     1.3.0\nv purrr     1.0.2     \n-- Conflicts ------------------------------------------ tidyverse_conflicts() --\nx dplyr::filter() masks stats::filter()\nx dplyr::lag()    masks stats::lag()\ni Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(openxlsx)\nlibrary(janitor)\n\n\nAttaching package: 'janitor'\n\nThe following objects are masked from 'package:stats':\n\n    chisq.test, fisher.test\n\nlibrary(scales)\n\n\nAttaching package: 'scales'\n\nThe following object is masked from 'package:purrr':\n\n    discard\n\nThe following object is masked from 'package:readr':\n\n    col_factor\n\nlibrary(tictoc)\nlibrary(furrr)\n\nLoading required package: future\n\nlibrary(ggthemes)\nlibrary(gt)\n\noptions(scipen = 999)\nsource(\"additional_functions.R\")\nsc &lt;- scales::comma"
  },
  {
    "objectID": "exercises/day1.html#task-1-allocate-indirect-cost",
    "href": "exercises/day1.html#task-1-allocate-indirect-cost",
    "title": "Day 1 - Building a Performance Measure Case",
    "section": "Task 1: Allocate Indirect Cost",
    "text": "Task 1: Allocate Indirect Cost\nWe know that we have to allocate indirect costs onto the individual product. Let’s tale Material Cost as an example:\n\nDirect Cost Elite (DC1): 30,000 €\nDirect Cost Premium (DC2): 70,000 €\nIndirect Cost (IC): 40,000\n\nThe general Formula for allocating indirect Cost is:\n\\[\nIC_{c,i} = IC_{c}*\\frac{DC_{c,i}}{\\sum_{i} DC_i}\n\\]\n\nTask 1A: Material Cost Allocation Preparation\nUse the given data to calculate the cost allocation:\n\nmat_dic &lt;- c(\"Elite\" = 30000, \"Premium\" = 70000)\nmat_inc &lt;- 40000\n\nToDo: Calculate the correct value for mat_ac\n\nmat_alc &lt;- NULL # YOUR CALCULATION HERE\nmat_alc &lt;- mat_inc * (mat_dic / sum(mat_dic))\nmat_alc\n\n  Elite Premium \n  12000   28000 \n\n\nCheck Your Result\n\ncheck_named_vector(mat_alc, c(\"Elite\" = 12000, \"Premium\" = 28000))\n\nSuccess: Correct Values and Names\n\n\n\n\nTask 1B: Write a general cost allocation formula\nEnsure the function only accepts named numeric vectors.\nName conventions: .m_dic for the direct cost vector, and .s_inc for the indirect cost (m_ stands for multiple values and s_ stands for single values).\n\nallocate_indirect_cost &lt;- function(.m_dic, .s_inc) {\n  # YOUR CODE HERE\n}\n\nallocate_indirect_cost &lt;- function(.m_dic, .s_inc) {\n  if (!is.numeric(.m_dic)) stop(\".m_dic must be a numeric vector\", call. = FALSE)\n  if (all(is.null(names(.m_dic)))) stop(\".m_dic must be a named vector\", call. = FALSE)\n  if (any(names(.m_dic) == \"\")) stop(\"All elements of .m_dic must be named\", call. = FALSE)\n  \n  .m_dic * (.s_inc / sum(.m_dic))\n}\n\nmat_alc &lt;- allocate_indirect_cost(mat_dic, mat_inc)\n\nCheck Your Result\n\ncheck_named_vector(mat_alc, c(\"Elite\" = 12000, \"Premium\" = 28000))\n\nSuccess: Correct Values and Names"
  },
  {
    "objectID": "exercises/day1.html#task-2-add-cost-vectors-for-products",
    "href": "exercises/day1.html#task-2-add-cost-vectors-for-products",
    "title": "Day 1 - Building a Performance Measure Case",
    "section": "Task 2: Add Cost Vectors for Products",
    "text": "Task 2: Add Cost Vectors for Products\nOne of the many nice thing in Accounting is, that you most of the time you only need the 4 arithmetical operators (+, -, *, / - In case you forgot them). Indeed, looking at the Cost Allocation Table we see that we only need one other Function, namely adding up the individual cost\n\nTask 2A: Write a general Formula for adding Cost\nWrite a formula (sum_cost) for cost allocation Make sure that the function only takes a named numeric vector as input (i.e. it throws an error if the vector is not numeric or not named) The Function should take an arbitrary number of of named vectors (the cost vectors) and returns a the piece-wise sum of those elements. E.g. taking the cost vectors we calculated:\n\n`cost_mat_dc &lt;- c(“Elite” = 30000, “Premium” = 70000)`\n`alloc_mat_ic &lt;- c(“Elite” = 12000, “Premium” = 28000)`\n\nIt should return: `c(“Elite” = 42000, “Premium” = 98000)`\nUsing inputs of unknown lengths, can be accomplished in R in two separate ways:\n\nUsing a list: Put every single vector into a list element\nUsing the … operator: [PLEASE EXPLAIN]\n\n\nsum_cost &lt;- function(...) {\n  purrr::pmap_dbl(list(...), sum)\n}\n\ncost_mat_tot &lt;- sum_cost(cost_mat_dc, alloc_mat_ic )\n\nCheck\n\ncost_mat_tot == c(\"Elite\" = 42000, \"Premium\" = 98000)\n\n  Elite Premium \n   TRUE    TRUE \n\nnames(alloc_mat_ic) == c(\"Elite\" = \"Elite\", \"Premium\" =  \"Premium\")\n\n  Elite Premium \n   TRUE    TRUE"
  },
  {
    "objectID": "exercises/day1.html#task-3-using-real-data-for-cost-allocation",
    "href": "exercises/day1.html#task-3-using-real-data-for-cost-allocation",
    "title": "Day 1 - Building a Performance Measure Case",
    "section": "Task 3: Using Real Data for Cost Allocation",
    "text": "Task 3: Using Real Data for Cost Allocation\nTo understand and compute the cost allocation using the lecture data, we’ll extract it from an Excel sheet and perform specific operations based on the data’s structure.\n\ntab_cost &lt;- tibble::as_tibble(\n  openxlsx::read.xlsx(\"../Business Case.xlsx\", \"Cost1\")\n  ) %&gt;%\n  janitor::clean_names()\ntab_cost\n\n# A tibble: 9 x 6\n  type     product department    amount distr   range_std\n  &lt;chr&gt;    &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;\n1 Direct   Elite   Material       30000 normal       5000\n2 Direct   Premium Material       70000 normal       7500\n3 Indirect &lt;NA&gt;    Material       40000 uniform      5000\n4 Direct   Elite   Manufacturing  40000 normal       2500\n5 Direct   Premium Manufacturing  50000 normal       1500\n6 Indirect &lt;NA&gt;    Manufacturing 135000 uniform     25000\n7 Indirect &lt;NA&gt;    Admin          73000 uniform      7500\n8 Indirect &lt;NA&gt;    Marketing      36500 uniform      3750\n9 Company  &lt;NA&gt;    &lt;NA&gt;           30000 uniform     22500\n\n\nHere, we use the openxlsx package to read the specific sheet “Cost1” from the Excel file. This data is then converted into a tibble (a modern form of R’s data frame) for easier manipulation. The clean_names() function from the janitor package is used to ensure our column names are consistent and easy to work with.\n\nTask 3A: Writing a formula to read product cost\nObjective: For this task, your goal is to write a function named filter_cost_input that filters the data for a specific cost type (e.g., Direct or Indirect) and a specific department (e.g., Material, Manufacturing). This function should return a named numeric vector where names are products, and values are the associated costs.\nYOUR FUNCTION:\n\nfilter_cost_input &lt;- function(.tab, .type, .dep) {\n  # YOUR CODE HERE\n}\n\nInstructions:\n\nUse the filter() function from the dplyr package to filter the table based on the given cost type and department.\nAfter filtering, arrange the results based on the product name. This will ensure consistency in later steps.\nNow, you’ll need to generate a named vector from the filtered results. This can be achieved using the mutate() function to set the names of the amount column to be the respective product names.\nFinally, extract just the named amount vector using the pull() function.\n\n\nfilter_cost_input &lt;- function(.tab, .type, .dep) {\n  .tab %&gt;%\n    dplyr::filter(type == .type, department == .dep) %&gt;%\n    dplyr::arrange(product) %&gt;%\n    dplyr::mutate(amount = purrr::set_names(amount, product)) %&gt;%\n    dplyr::pull(amount)\n}\n\nCheck Your Result\n\nmat_dic &lt;- filter_cost_input(tab_cost, \"Direct\", \"Material\")\nmat_dic\n\n  Elite Premium \n  30000   70000 \n\n\n\ncheck_named_vector(mat_dic, c(\"Elite\" = 30000, \"Premium\" = 70000))\n\nSuccess: Correct Values and Names\n\n\n\n\nTask 3B: Writing formulas to get Cost Allocation List\nObjective: The aim of this exercise is to calculate different types of costs, both direct and indirect, and allocate them properly across products.\nStep-by-Step Guide:\n\nUnderstand the Structure: The get_cost_allocations function will compute various costs and store them in a list. This list will help organize and categorize costs according to their type and department.\nMaterial Costs:\n\nDirect Material Cost (mat_dic): This is already computed for you using the filter_cost_input function. It represents the costs directly linked to materials for each product.\nIndirect Material Cost (mat_inc): These costs are associated with materials but can’t be linked to a specific product. Instead, they’re spread out across all products.\nAllocated Material Cost (mat_alc): Here, you need to allocate the indirect material cost across all products based on some allocation rule (like proportion of direct costs or units produced). Use the allocate_indirect_cost function with mat_dic and mat_inc as arguments.\nTotal Material Cost (mat_tot): This is the sum of direct material cost and allocated indirect material cost. Use the sum_cost function.\n\nManufacturing Costs:\n\nDirect Manufacturing Cost (man_dic) and Indirect Manufacturing Cost (man_inc): These are computed in a manner similar to material costs.\nAllocated Manufacturing Cost (man_alc): Allocate the indirect manufacturing cost across products. Consider factors like machine hours or labor hours if relevant.\nTotal Manufacturing Cost (man_tot): Sum up the direct and allocated indirect manufacturing costs.\n\nAdministrative Costs:\n\nIndirect Admin Cost (adm_inc): As administrative costs are often indirect, allocate these across products based on a suitable allocation base (e.g., total costs or sales).\nAllocated Admin Cost (adm_alc): Spread the indirect admin cost using an appropriate rule.\n\nMarketing Costs:\n\nIndirect Marketing Cost (mar_inc): These are the costs associated with marketing activities that can’t be directly linked to a product.\nAllocated Marketing Cost (mar_alc): Distribute the marketing costs among products.\n\nTotal Product Cost (prd_tot): This is a summation of all costs associated with a product - material, manufacturing, administrative, and marketing. Ensure all costs are considered, both direct and allocated indirect.\n\nUse the Functions allocate_indirect_cost() and sum_cost() to complete the get_cost_allocations() functions\nYOUR FUNCTION:\n\nget_cost_allocations &lt;- function(.tab_cost) {\n  # Create an empty list to store values\n  lst_ &lt;- list()\n\n  # Material Cost\n  lst_[[\"mat_dic\"]] &lt;- filter_cost_input(.tab_cost, \"Direct\", \"Material\")   # Direct Material Cost\n  lst_[[\"mat_inc\"]] &lt;- filter_cost_input(.tab_cost, \"Indirect\", \"Material\") # Indirect Material Cost\n  lst_[[\"mat_alc\"]] &lt;- NULL # YOUR CODE HERE                                # Allocated Material Cost\n  lst_[[\"mat_tot\"]] &lt;- NULL # YOUR CODE HERE                                # Total Material Cost\n\n  # Manufacturing Cost\n  lst_[[\"man_dic\"]] &lt;- filter_cost_input(.tab_cost, \"Direct\", \"Manufacturing\")   # Direct Manufacturing Cost\n  lst_[[\"man_inc\"]] &lt;- filter_cost_input(.tab_cost, \"Indirect\", \"Manufacturing\") # Indirect Manufacturing Cost\n  lst_[[\"man_alc\"]] &lt;- NULL # YOUR CODE HERE                                     # Allocated Manufacturing Cost\n  lst_[[\"man_tot\"]] &lt;- NULL # YOUR CODE HERE                                     # Total Manufacturing Cost\n\n  # Administrative Cost\n  lst_[[\"adm_inc\"]] &lt;- filter_cost_input(.tab_cost, \"Indirect\", \"Admin\") # Indirect Admin Cost\n  lst_[[\"adm_alc\"]] &lt;- NULL # YOUR CODE HERE                             # Allocated Admin Cost\n\n  # Marketing Cost\n  lst_[[\"mar_inc\"]] &lt;- filter_cost_input(.tab_cost, \"Indirect\", \"Marketing\") # Indirect Marketing Cost\n  lst_[[\"mar_alc\"]] &lt;- NULL # YOUR CODE HERE                                 # Allocated Marketing Cost\n\n  # Total Product Cost\n  lst_[[\"prd_tot\"]] &lt;- NULL # YOUR CODE HERE\n\n  return(lst_)\n}\n\n\nget_cost_allocation_list &lt;- function(.tab_cost) {\n  lst_ &lt;- list()\n\n  lst_[[\"mat_dic\"]] &lt;- filter_cost_input(.tab_cost, \"Direct\", \"Material\")\n  lst_[[\"mat_inc\"]] &lt;- filter_cost_input(.tab_cost, \"Indirect\", \"Material\")\n  lst_[[\"mat_alc\"]] &lt;- allocate_indirect_cost(lst_$mat_dic, lst_$mat_inc)\n  lst_[[\"mat_tot\"]] &lt;- sum_cost(lst_$mat_dic, lst_$mat_alc)\n\n  lst_[[\"man_dic\"]] &lt;- filter_cost_input(.tab_cost, \"Direct\", \"Manufacturing\")\n  lst_[[\"man_inc\"]] &lt;- filter_cost_input(.tab_cost, \"Indirect\", \"Manufacturing\")\n  lst_[[\"man_alc\"]] &lt;- allocate_indirect_cost(lst_$man_dic, lst_$man_inc)\n  lst_[[\"man_tot\"]] &lt;- sum_cost(lst_$mat_tot, lst_$man_dic, lst_$man_alc)\n\n  lst_[[\"adm_inc\"]] &lt;- filter_cost_input(.tab_cost, \"Indirect\", \"Admin\")\n  lst_[[\"adm_alc\"]] &lt;- allocate_indirect_cost(lst_$man_tot, lst_$adm_inc)\n\n  lst_[[\"mar_inc\"]] &lt;- filter_cost_input(.tab_cost, \"Indirect\", \"Marketing\")\n  lst_[[\"mar_alc\"]] &lt;- allocate_indirect_cost(lst_$man_tot, lst_$mar_inc)\n\n  lst_[[\"prd_tot\"]] &lt;- sum_cost(lst_$man_tot, lst_$adm_alc, lst_$mar_alc)\n\n  return(lst_)\n}\n\nFunction Breakdown:\n\nFunction Name: get_cost_allocation_skeleton\n\nThis name suggests that we are fetching or creating a foundational structure for our cost allocations.\n\nThe tibble::tribble Function:\n\nThis function is from the tibble package and helps in creating a small table (or tibble) in a readable form.\nThe ~sign and ~var are column names in this table. Each subsequent line in the function provides a row of data for these columns.\n\n\nUsage:\nWhen you call the function, it returns the described tibble structure. This “skeleton” serves as a roadmap for allocating and tallying up various costs. As you proceed with the exercise, you will populate this table with actual monetary values corresponding to each cost type. This visual representation helps in comprehending the flow and accumulation of different cost components.\n\nget_cost_allocation_skeleton &lt;- function() {\n  tibble::tribble(\n    ~sign, ~var,\n    \" \", \"Direct Material Costs\",\n    \"+\", \"Indirect Material Costs\",\n    \"=\", \"Material Costs\",\n    \"+\", \"Direct Manufacturing Costs\",\n    \"+\", \"Indirect Manufacturing Costs\",\n    \"=\", \"Manufacturing Costs\",\n    \"+\", \"Indirect Administration Costs\",\n    \"+\", \"Indirect Marketing Costs\",\n    \"=\", \"Total Product Costs\"\n  )\n}\n\n\nget_cost_allocation_skeleton()\n\n# A tibble: 9 x 2\n  sign  var                          \n  &lt;chr&gt; &lt;chr&gt;                        \n1 \" \"   Direct Material Costs        \n2 \"+\"   Indirect Material Costs      \n3 \"=\"   Material Costs               \n4 \"+\"   Direct Manufacturing Costs   \n5 \"+\"   Indirect Manufacturing Costs \n6 \"=\"   Manufacturing Costs          \n7 \"+\"   Indirect Administration Costs\n8 \"+\"   Indirect Marketing Costs     \n9 \"=\"   Total Product Costs          \n\n\n\n\nTask 3C: Display Cost Allocation Table\nIn this task, your goal is to use the pre-defined functions get_cost_allocation_list() and get_cost_allocation_skeleton() to construct the final Cost Allocation Table.\nThe Cost Allocation Table is crucial because it breaks down both direct and indirect costs, allowing a company to understand its cost structure better. By the end of this task, you should be able to represent all these costs in a well-organized table.\nInstructions:\n\nUnderstanding the Skeleton:\n\nBefore jumping into building the entire table, let’s familiarize ourselves with the get_cost_allocation_skeleton() function. This function provides a structured, step-by-step representation of how costs are compiled. Each row of the output represents either an individual cost or a summation.\nTry running the function by itself to see its output!\n\nFetching the Costs:\n\nThe get_cost_allocation_list() function is designed to extract various types of costs from the dataset. It returns a list containing costs categorized by their type (direct, indirect) and nature (material, manufacturing, etc.).\nFor the purpose of this task, run the function with your dataset and examine its output. Familiarize yourself with the different types of costs it provides.\n\nBuilding the Table:\n\nYour main challenge is to construct the Cost Allocation Table. This will involve integrating the structure provided by the skeleton with the actual cost data.\nThink of how you can combine the structured format of the skeleton with the actual cost numbers. You’ll need to fetch each relevant cost from the list and place it in the correct position within the table.\nNote: The skeleton uses signs like “+” and “=” to signify addition and summation. This can guide you on where and how to place and calculate costs.\n\nSteps to Consider for the Function:\n\nStart by fetching the costs using get_cost_allocation_list().\nUse the output of get_cost_allocation_skeleton() as your foundational table.\nFor each line in the skeleton, fetch the corresponding cost from your list and append it as a new column to the table.\nOnce you’ve placed all the individual costs, think about the rows that require summation (those with “=”). Calculate these using the appropriate rows.\nContinue this process until you’ve constructed the entire table.\nAdd a Total Column to the Table that shows the total cost over all Products\n\nTesting:\n\nOnce you’ve written your function, test it with the given data. Your output should align with the structure of the skeleton and display all the relevant costs.\n\n\nTips:\n\nRemember, you’re not starting from scratch! You have a structured format and categorized data. It’s all about bringing them together in the right order.\nThe use of functions from packages like dplyr and purrr can significantly simplify data manipulation and transformation. If you’re familiar with these, consider how they can assist in your task.\n\n\nget_cost_allocation_table &lt;- function(.tab_cost) {\n  # YOUR CODE HERE\n}\n\nget_cost_allocation_table &lt;- function(.tab_cost) {\n  lst_cost_ &lt;- get_cost_allocation_list(.tab_cost)\n  lst_cost_ &lt;- lst_cost_[c(\n    \"mat_dic\", \"mat_alc\", \"mat_tot\", \n    \"man_dic\", \"man_alc\", \"man_tot\", \n    \"adm_alc\", \n    \"mar_alc\", \n    \"prd_tot\"\n  )]\n  \n  make_table_row &lt;- function(.vec) {\n    tibble::as_tibble(t(.vec))\n  }\n  \n  get_cost_allocation_skeleton() %&gt;%\n    dplyr::bind_cols(\n      dplyr::bind_rows(purrr::map(lst_cost_, make_table_row))\n      ) %&gt;%\n    dplyr::mutate(Total = rowSums(.[, -(1:2)]), .after = var)\n}\n\n\nget_cost_allocation_table(.tab_cost = tab_cost)\n\n# A tibble: 9 x 5\n  sign  var                            Total  Elite Premium\n  &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;\n1 \" \"   Direct Material Costs         100000  30000   70000\n2 \"+\"   Indirect Material Costs        40000  12000   28000\n3 \"=\"   Material Costs                140000  42000   98000\n4 \"+\"   Direct Manufacturing Costs     90000  40000   50000\n5 \"+\"   Indirect Manufacturing Costs  135000  60000   75000\n6 \"=\"   Manufacturing Costs           365000 142000  223000\n7 \"+\"   Indirect Administration Costs  73000  28400   44600\n8 \"+\"   Indirect Marketing Costs       36500  14200   22300\n9 \"=\"   Total Product Costs           474500 184600  289900\n\n\n\nformat_table(get_cost_allocation_table(tab_cost))\n\n\n\n\n\n  \n    \n    \n      sign\n      var\n      Total\n      Elite\n      Premium\n    \n  \n  \n     \nDirect Material Costs\n100,000\n30,000\n70,000\n    +\nIndirect Material Costs\n40,000\n12,000\n28,000\n    =\nMaterial Costs\n140,000\n42,000\n98,000\n    +\nDirect Manufacturing Costs\n90,000\n40,000\n50,000\n    +\nIndirect Manufacturing Costs\n135,000\n60,000\n75,000\n    =\nManufacturing Costs\n365,000\n142,000\n223,000\n    +\nIndirect Administration Costs\n73,000\n28,400\n44,600\n    +\nIndirect Marketing Costs\n36,500\n14,200\n22,300\n    =\nTotal Product Costs\n474,500\n184,600\n289,900"
  },
  {
    "objectID": "exercises/index.html",
    "href": "exercises/index.html",
    "title": "Projects",
    "section": "",
    "text": "arXiv Preprint | Code\nOver the centuries, I have devoted countless hours to deciphering and translating the ancient scripts and dialects of the various peoples of Middle-earth. My goal is to gain a deeper understanding of the cultures and histories of these peoples by studying their languages. Currently, I am working on a monograph that explores the linguistic roots of the Elvish languages. Through extensive research and analysis, I hope to shed light on the connections between the different dialects of Elvish and their origins. This project has been particularly challenging, as Elvish is a complex and nuanced language, but I am determined to see it through to completion."
  },
  {
    "objectID": "exercises/index.html#the-languages-of-middle-earth",
    "href": "exercises/index.html#the-languages-of-middle-earth",
    "title": "Projects",
    "section": "",
    "text": "arXiv Preprint | Code\nOver the centuries, I have devoted countless hours to deciphering and translating the ancient scripts and dialects of the various peoples of Middle-earth. My goal is to gain a deeper understanding of the cultures and histories of these peoples by studying their languages. Currently, I am working on a monograph that explores the linguistic roots of the Elvish languages. Through extensive research and analysis, I hope to shed light on the connections between the different dialects of Elvish and their origins. This project has been particularly challenging, as Elvish is a complex and nuanced language, but I am determined to see it through to completion."
  },
  {
    "objectID": "exercises/index.html#the-history-of-the-war-of-the-ring",
    "href": "exercises/index.html#the-history-of-the-war-of-the-ring",
    "title": "Projects",
    "section": "The History of the War of the Ring",
    "text": "The History of the War of the Ring\n\narXiv Preprint | Code\nI am creating a comprehensive and detailed history of the conflict that goes beyond the surface-level events. By gathering information from a variety of sources, including my own memories, written accounts, and oral histories, I hope to shed new light on this important period in Middle-earth’s history and provide valuable insights into the motivations and actions of the various players involved.\n\nView the tutorial for this template (+ download link)"
  },
  {
    "objectID": "exercises/day1.html#task-2-summing-cost-vectors",
    "href": "exercises/day1.html#task-2-summing-cost-vectors",
    "title": "Day 1 - Building a Performance Measure Case",
    "section": "Task 2: Summing Cost Vectors",
    "text": "Task 2: Summing Cost Vectors\nThe goal here is to devise a formula that can take multiple named numeric vectors as its input and return a new vector whose elements are the piece-wise sum of the elements in the input vectors. This formula will allow you to combine, for example, direct costs and allocated indirect costs to derive the total costs.\n\nTask 2A: Cost Summation Formula\nYou aim to create a function, sum_cost, that can receive any number of named numeric vectors and return their piece-wise sum.\nThe two common methods in R to handle an arbitrary number of function inputs are:\n\nUsing a list: Each vector is considered an item in the list. This method is more structured but requires each vector to be manually added to the list.\nUsing the ... operator: This is a placeholder for any number of arguments that can be passed to a function. It provides flexibility because you don’t have to specify in advance how many arguments you’re going to use. Later, inside the function, you can convert ... to a list using the list(...) function, allowing you to manipulate the arguments as a single list object.\n\nGiven these methods, here’s how you can create the sum_cost function:\n\nsum_cost &lt;- function(...) {\n  # YOUR CODE HERE\n}\n\nsum_cost &lt;- function(...) {\n  purrr::pmap_dbl(list(...), sum)\n}\n\n\nmat_tot &lt;- sum_cost(mat_dic, mat_inc )\n\nCheck Your Result\n\ncheck_named_vector(mat_tot, c(\"Elite\" = 70000, \"Premium\" = 110000))\n\nSuccess: Correct Values and Names"
  },
  {
    "objectID": "exercises/day1.html#task-4a-subtracting-cost-vectors-for-revenue-vectors",
    "href": "exercises/day1.html#task-4a-subtracting-cost-vectors-for-revenue-vectors",
    "title": "Day 1 - Building a Performance Measure Case",
    "section": "Task 4A: Subtracting Cost Vectors for Revenue Vectors",
    "text": "Task 4A: Subtracting Cost Vectors for Revenue Vectors\nYou aim to create a function, substract_cost, that can receive any number of named numeric vectors and subtract values from the first value.\nThe two common methods in R to handle an arbitrary number of function inputs are:\n\nUsing a list: Each vector is considered an item in the list. This method is more structured but requires each vector to be manually added to the list.\nUsing the ... operator: This is a placeholder for any number of arguments that can be passed to a function. It provides flexibility because you don’t have to specify in advance how many arguments you’re going to use. Later, inside the function, you can convert ... to a list using the list(...) function, allowing you to manipulate the arguments as a single list object.\n\nGiven these methods, here’s how you can create the substract_cost function:\n\nsubtract_cost &lt;- function(...) {\n  purrr::pmap_dbl(list(...), ~ sum(c(...)[1], -c(...)[-1]))\n}\n\nCheck Your Result\n\nrevenues &lt;- c(\"Elite\" = 100000, \"Premium\" = 250000)\nvar_cost &lt;- c(\"Elite\" = 70000, \"Premium\" = 120000)\n\ncm1 &lt;- subtract_cost(revenues, var_cost)\n\n\ncheck_named_vector(cm1, c(\"Elite\" = 30000, \"Premium\" = 130000))\n\nSuccess: Correct Values and Names"
  },
  {
    "objectID": "exercises/day1.html#task-4b-writing-a-formula-to-read-product-revenues",
    "href": "exercises/day1.html#task-4b-writing-a-formula-to-read-product-revenues",
    "title": "Day 1 - Building a Performance Measure Case",
    "section": "Task 4B: Writing a formula to read product revenues",
    "text": "Task 4B: Writing a formula to read product revenues\nObjective: For this task, your goal is to write a function named filter_revenue_input This function should return a named numeric vector where names are products, and values are the associated costs.\nYOUR FUNCTION:\n\nfilter_revenue_input &lt;- function(.tab, .type, .dep) {\n  # YOUR CODE HERE\n}\n\n\nfilter_revenue_input &lt;- function(.tab) {\n  .tab %&gt;%\n    dplyr::arrange(product) %&gt;%\n    dplyr::mutate(amount = purrr::set_names(amount, product)) %&gt;%\n    dplyr::pull(amount)\n}\n\n\nfilter_revenue_input(tab_revenue)\n\n  Elite Premium \n 250000  112500"
  },
  {
    "objectID": "exercises/day1.html#task-4c-writing-formulas-to-get-contribution-margin-list",
    "href": "exercises/day1.html#task-4c-writing-formulas-to-get-contribution-margin-list",
    "title": "Day 1 - Building a Performance Measure Case",
    "section": "Task 4C: Writing formulas to get Contribution Margin List",
    "text": "Task 4C: Writing formulas to get Contribution Margin List\nRemember Task 3B. Use the Functions subtract_cost() and sum_cost() to complete the get_cost_allocations_and_list() function.\n\nget_cost_allocation_and_cm_list &lt;- function(.tab_cost, .tab_revenue) {\n  lst_cost_ &lt;- get_cost_allocation_list(.tab_cost) # The Cost Allocation List\n  lst_cm_   &lt;- list() # A new List for Contribution Margin\n\n  lst_cm_[[\"revenues\"]] &lt;- filter_revenue_input(.tab_revenue) # Revenues\n  lst_cm_[[\"var_cost\"]] &lt;- NULL # YOUR CODE HERE    \n  lst_cm_[[\"cm1\"]]      &lt;- NULL # YOUR CODE HERE    \n  lst_cm_[[\"fix_cost\"]] &lt;- NULL # YOUR CODE HERE    \n  lst_cm_[[\"cm2\"]]      &lt;- NULL # YOUR CODE HERE    \n  \n  return(c(lst_cost_, lst_cm_)) # Return the combined list\n}\n\n\nget_cost_allocation_and_cm_list &lt;- function(.tab_cost, .tab_revenue) {\n  lst_cost_ &lt;- get_cost_allocation_list(.tab_cost)\n  lst_cm_   &lt;- list()\n\n  lst_cm_[[\"revenues\"]] &lt;- filter_revenue_input(.tab_revenue)\n  lst_cm_[[\"var_cost\"]] &lt;- sum_cost(lst_cost_$mat_dic, lst_cost_$man_dic)\n  lst_cm_[[\"cm1\"]]      &lt;- subtract_cost(lst_cm_$revenues, lst_cm_$var_cost)\n  lst_cm_[[\"fix_cost\"]] &lt;- sum_cost(lst_cost_$mat_alc, lst_cost_$man_alc, lst_cost_$adm_alc, lst_cost_$mar_alc)\n  lst_cm_[[\"cm2\"]]      &lt;- subtract_cost(lst_cm_$cm1, lst_cm_$fix_cost)\n  \n  return(c(lst_cost_, lst_cm_))\n}"
  },
  {
    "objectID": "exercises/day1.html#task-4d-display-contribution-margin-table",
    "href": "exercises/day1.html#task-4d-display-contribution-margin-table",
    "title": "Day 1 - Building a Performance Measure Case",
    "section": "Task 4D: Display Contribution Margin Table",
    "text": "Task 4D: Display Contribution Margin Table\nRemember Task 3C.\n\nget_contribution_margin_skeleton &lt;- function() {\n  tibble::tribble(\n    ~sign, ~var,\n    \" \", \"Revenue\",\n    \"-\", \"Variable Cost\",\n    \"=\", \"Contribution Margin 1\",\n    \"-\", \"Product Fix Cost\",\n    \"=\", \"Contribution Margin 2\",\n  )\n}\n\n\nmake_cm_table &lt;- function(.tab_cost, .tab_revenue) {\n  lst_cost_cm_ &lt;- get_cost_allocation_and_cm_list(.tab_cost, .tab_revenue)\n  lst_cm_ &lt;- lst_cost_cm_[c(\"revenues\", \"var_cost\", \"cm1\", \"fix_cost\", \"cm2\")]\n  \n  make_table_row &lt;- function(.vec) {\n    tibble::as_tibble(t(.vec))\n  }\n  \n  get_contribution_margin_skeleton() %&gt;%\n    dplyr::bind_cols(\n      dplyr::bind_rows(purrr::map(lst_cm_, make_table_row))\n      ) %&gt;%\n    dplyr::mutate(Total = rowSums(.[, -(1:2)]), .after = var)\n}\n\nformat_table(make_cm_table(tab_cost, tab_revenue))\n\n\n\n\n\n  \n    \n    \n      sign\n      var\n      Total\n      Elite\n      Premium\n    \n  \n  \n     \nRevenue\n362,500\n250,000\n112,500\n    -\nVariable Cost\n190,000\n70,000\n120,000\n    =\nContribution Margin 1\n172,500\n180,000\n(7,500)\n    -\nProduct Fix Cost\n284,500\n114,600\n169,900\n    =\nContribution Margin 2\n(112,000)\n65,400\n(177,400)"
  }
]